
    public Godot.ArrayMesh CreateMeshChunkEdge(ref byte[] Field, Vector3I FieldSize, byte IsoLevel, ref byte[] FieldZ)
    {
        // pro každý gridcell je tu 15 vertexů -> největší počet trojuhelníku je 5.
        int VeretxArraySize = (FieldSize.X + 1) * (FieldSize.Y + 1) * (FieldSize.Z + 1) * 15;
        Vector3[] Vertices = new Vector3[VeretxArraySize];
        Vector3[] Normals = new Vector3[VeretxArraySize];
        // pokud je bod mimo pole tak zjistit k jakému poli patří...


        for (uint z = 0; z < FieldSize.Z - 1; z++)
        {
            for (uint y = 0; y < FieldSize.Y - 1; y++)
            {
                for (uint x = 0; x < FieldSize.X - 1; x++)
                {
                    // základní pozice blocku / celly v 3D poli
                    uint CellPos = x + y * (uint)FieldSize.X + z * (uint)FieldSize.X * (uint)FieldSize.Y;
                    // zjistíme o jaký typ struktury vertexu se jedná.
                    uint CubeIndex = 0;
                    //
                    if (Field[CellPos] > IsoLevel) CubeIndex += 1;
                    if (Field[CellPos + 1] > IsoLevel) CubeIndex += 2;
                    if (Field[CellPos + ((uint)FieldSize.X * (uint)FieldSize.Y) + 1] > IsoLevel) CubeIndex += 4;
                    if (Field[CellPos + ((uint)FieldSize.X * (uint)FieldSize.Y)] > IsoLevel) CubeIndex += 8;
                    if (Field[CellPos + (uint)FieldSize.X] > IsoLevel) CubeIndex += 16;
                    if (Field[CellPos + (uint)FieldSize.X + 1] > IsoLevel) CubeIndex += 32;
                    if (Field[CellPos + (uint)FieldSize.X + ((uint)FieldSize.X * (uint)FieldSize.Y) + 1] > IsoLevel) CubeIndex += 64;
                    if (Field[CellPos + (uint)FieldSize.X + ((uint)FieldSize.X * (uint)FieldSize.Y)] > IsoLevel) CubeIndex += 128;

                    // díky získanému indexu sestrojíme vertexy pomocí tabulky
                    for (int i = 0; i < 15; i++)
                    {
                        int CellVertexPos = (int)CellPos * 15 + i;
                        int VertexIndex = TriangleTable[CubeIndex, i];
                        if (TriangleTable[CubeIndex, i] != -1)
                        {
                            Vector3I i1 = EdgeVertices[VertexIndex * 2];
                            Vector3I i2 = EdgeVertices[VertexIndex * 2 + 1];

                            byte field_point1 = Field[CellPos + i1.X + i1.Y * (uint)FieldSize.X + i1.Z * ((uint)FieldSize.X * (uint)FieldSize.Y)];
                            byte field_point2 = Field[CellPos + i2.X + i2.Y * (uint)FieldSize.X + i2.Z * ((uint)FieldSize.X * (uint)FieldSize.Y)];

                            Vector3 v1 = new(i1.X, i1.Y, i1.Z);
                            Vector3 v2 = new(i2.X, i2.Y, i2.Z);

                            float InterpolatedValue = Mathf.Abs((float)IsoLevel - (float)field_point1) / Mathf.Abs((float)field_point1 - (float)field_point2);

                            Vector3 vert = (v2 - v1) * InterpolatedValue + v1;

                            Vertices[CellVertexPos] = new Vector3((float)x + vert.X, (float)y + vert.Y, (float)z + vert.Z);
                        }
                        else
                        {
                            Vertices[CellVertexPos] = new Vector3(0.0f, 0.0f, 0.0f);
                        }
                    }
                    // vypočítáme normál
                    for (int i = 0; i < 15; i += 3)
                    {
                        int CellVertexPos = (int)CellPos * 15 + i;
                        Vector3 v1 = Vertices[CellVertexPos + 1] - Vertices[CellVertexPos];
                        Vector3 v2 = Vertices[CellVertexPos + 2] - Vertices[CellVertexPos];
                        Vector3 Cross1 = v2.Cross(v1);
                        Normals[CellVertexPos] = Cross1;
                        Normals[CellVertexPos + 1] = Cross1;
                        Normals[CellVertexPos + 2] = Cross1;
                    }
                }
            }
        }

        //
        //
        //

        for (uint y = 0; y < FieldSize.Y - 1; y++)
        {
            for (uint x = 0; x < FieldSize.X - 1; x++)
            {
                uint z = (uint)FieldSize.Z - 1;
                uint CellPos = x + y * (uint)FieldSize.X + z * (uint)FieldSize.X * (uint)FieldSize.Y;
                uint CellPosZ = x + y * (uint)FieldSize.X;
                uint CubeIndex = 0;

                if (Field[CellPos] > IsoLevel) CubeIndex += 1;
                if (Field[CellPos + 1] > IsoLevel) CubeIndex += 2;

                if (FieldZ[CellPosZ + 1] > IsoLevel) CubeIndex += 4;
                if (FieldZ[CellPosZ] > IsoLevel) CubeIndex += 8;

                if (Field[CellPos + (uint)FieldSize.X] > IsoLevel) CubeIndex += 16;
                if (Field[CellPos + (uint)FieldSize.X + 1] > IsoLevel) CubeIndex += 32;

                if (FieldZ[CellPosZ + (uint)FieldSize.X + 1] > IsoLevel) CubeIndex += 64;
                if (FieldZ[CellPosZ + (uint)FieldSize.X] > IsoLevel) CubeIndex += 128;

                // díky získanému indexu sestrojíme vertexy pomocí tabulky
                for (int i = 0; i < 15; i++)
                {
                    int CellVertexPos = (int)CellPos * 15 + i;
                    int VertexIndex = TriangleTable[CubeIndex, i];
                    if (TriangleTable[CubeIndex, i] != -1)
                    {
                        Vector3I i1 = EdgeVertices[VertexIndex * 2];
                        Vector3I i2 = EdgeVertices[VertexIndex * 2 + 1];

                        byte field_point1;
                        byte field_point2;
                        if (i1.Z == 1)
                        {
                            field_point1 = FieldZ[CellPosZ + i1.X + i1.Y * (uint)FieldSize.X];
                        }
                        else
                        {
                            field_point1 = Field[CellPos + i1.X + i1.Y * (uint)FieldSize.X + i1.Z * ((uint)FieldSize.X * (uint)FieldSize.Y)];
                        }

                        if (i2.Z == 1)
                        {
                            field_point2 = FieldZ[CellPosZ + i2.X + i2.Y * (uint)FieldSize.X];
                        }
                        else
                        {
                            field_point2 = Field[CellPos + i2.X + i2.Y * (uint)FieldSize.X + i2.Z * ((uint)FieldSize.X * (uint)FieldSize.Y)];
                        }

                        Vector3 v1 = new(i1.X, i1.Y, i1.Z);
                        Vector3 v2 = new(i2.X, i2.Y, i2.Z);

                        float InterpolatedValue = Mathf.Abs((float)IsoLevel - (float)field_point1) / Mathf.Abs((float)field_point1 - (float)field_point2);

                        Vector3 vert = (v2 - v1) * InterpolatedValue + v1;

                        Vertices[CellVertexPos] = new Vector3((float)x + vert.X, (float)y + vert.Y, (float)z + vert.Z);
                    }
                    else
                    {
                        Vertices[CellVertexPos] = new Vector3(0.0f, 0.0f, 0.0f);
                    }
                }
                // vypočítáme normál
                for (int i = 0; i < 15; i += 3)
                {
                    int CellVertexPos = (int)CellPos * 15 + i;
                    Vector3 v1 = Vertices[CellVertexPos + 1] - Vertices[CellVertexPos];
                    Vector3 v2 = Vertices[CellVertexPos + 2] - Vertices[CellVertexPos];
                    Vector3 Cross1 = v2.Cross(v1);
                    Normals[CellVertexPos] = Cross1;
                    Normals[CellVertexPos + 1] = Cross1;
                    Normals[CellVertexPos + 2] = Cross1;
                }
            }
        }
        for (uint z = 0; z < FieldSize.Z - 1; z++)
        {
            for (uint y = 0; y < FieldSize.Y - 1; y++)
            {
                for (uint x = 0; x < FieldSize.X - 1; x++)
                {
                    // základní pozice blocku / celly v 3D poli
                    uint CellPos = x + y * (uint)FieldSize.X + z * (uint)FieldSize.X * (uint)FieldSize.Y;
                    // zjistíme o jaký typ struktury vertexu se jedná.
                    uint CubeIndex = 0;
                    //
                    if (Field[CellPos] > IsoLevel) CubeIndex += 1;
                    if (Field[CellPos + 1] > IsoLevel) CubeIndex += 2;
                    if (Field[CellPos + ((uint)FieldSize.X * (uint)FieldSize.Y) + 1] > IsoLevel) CubeIndex += 4;
                    if (Field[CellPos + ((uint)FieldSize.X * (uint)FieldSize.Y)] > IsoLevel) CubeIndex += 8;
                    if (Field[CellPos + (uint)FieldSize.X] > IsoLevel) CubeIndex += 16;
                    if (Field[CellPos + (uint)FieldSize.X + 1] > IsoLevel) CubeIndex += 32;
                    if (Field[CellPos + (uint)FieldSize.X + ((uint)FieldSize.X * (uint)FieldSize.Y) + 1] > IsoLevel) CubeIndex += 64;
                    if (Field[CellPos + (uint)FieldSize.X + ((uint)FieldSize.X * (uint)FieldSize.Y)] > IsoLevel) CubeIndex += 128;

                    // díky získanému indexu sestrojíme vertexy pomocí tabulky
                    for (int i = 0; i < 15; i++)
                    {
                        int CellVertexPos = (int)CellPos * 15 + i;
                        int VertexIndex = TriangleTable[CubeIndex, i];
                        if (TriangleTable[CubeIndex, i] != -1)
                        {
                            Vector3I i1 = EdgeVertices[VertexIndex * 2];
                            Vector3I i2 = EdgeVertices[VertexIndex * 2 + 1];

                            byte field_point1 = Field[CellPos + i1.X + i1.Y * (uint)FieldSize.X + i1.Z * ((uint)FieldSize.X * (uint)FieldSize.Y)];
                            byte field_point2 = Field[CellPos + i2.X + i2.Y * (uint)FieldSize.X + i2.Z * ((uint)FieldSize.X * (uint)FieldSize.Y)];

                            Vector3 v1 = new(i1.X, i1.Y, i1.Z);
                            Vector3 v2 = new(i2.X, i2.Y, i2.Z);

                            float InterpolatedValue = Mathf.Abs((float)IsoLevel - (float)field_point1) / Mathf.Abs((float)field_point1 - (float)field_point2);

                            Vector3 vert = (v2 - v1) * InterpolatedValue + v1;

                            Vertices[CellVertexPos] = new Vector3((float)x + vert.X, (float)y + vert.Y, (float)z + vert.Z);
                        }
                        else
                        {
                            Vertices[CellVertexPos] = new Vector3(0.0f, 0.0f, 0.0f);
                        }
                    }
                    // vypočítáme normál
                    for (int i = 0; i < 15; i += 3)
                    {
                        int CellVertexPos = (int)CellPos * 15 + i;
                        Vector3 v1 = Vertices[CellVertexPos + 1] - Vertices[CellVertexPos];
                        Vector3 v2 = Vertices[CellVertexPos + 2] - Vertices[CellVertexPos];
                        Vector3 Cross1 = v2.Cross(v1);
                        Normals[CellVertexPos] = Cross1;
                        Normals[CellVertexPos + 1] = Cross1;
                        Normals[CellVertexPos + 2] = Cross1;
                    }
                }
            }
        }
        // vložíme data do meshe
        Godot.ArrayMesh arrMesh = new ArrayMesh();
        Godot.Collections.Array arrays = [];
        arrays.Resize((int)Mesh.ArrayType.Max);
        arrays[(int)Mesh.ArrayType.Vertex] = Vertices;
        arrays[(int)Mesh.ArrayType.Normal] = Normals;
        arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, arrays);
        return arrMesh;
    }