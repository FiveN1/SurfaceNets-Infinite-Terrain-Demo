using System;
using Godot;

namespace Octree
{
    public partial class Node
    {


        public struct FieldCube
        {
            byte values;
            int indices;
        }

        public void StichVertCube(Octree.Node rootNode, Vector3 centerPosition, ref int vertWriteIndex, ref int indexWriteIndex, Terrain22.Chunk activeChunk)
        {
            Vector3[] vertices = new Vector3[8];
            Vector3[] normals = new Vector3[8];
            int[] indices = new int[8];

            // Získáme 8 vertexů a jejich indexy pokud jsou v tomto bodu
            GetVertCube(ref vertices, ref normals, ref indices, rootNode, centerPosition);

            // zapíšeme vertexy které jsou mimo chunk, přitom také získáme jejich indexy
            for (int i = 0; i < 8; i++)
            {
                if (indices[i] == -1) // pokud mimo chunk, uložíme a získáme index
                {
                    activeChunk.meshData.vertexPositions[vertWriteIndex] = vertices[i];
                    activeChunk.meshData.vertexNormals[vertWriteIndex] = normals[i];
                    indices[i] = vertWriteIndex;
                    vertWriteIndex++;
                }
            }

            GD.Print("vertCube: ", centerPosition);
            for (int i = 0; i < 8; i++)
            {
                GD.Print("\tvertex: ", vertices[i], ", index: ", indices[i]);
            }

            byte caseCode = GetCaseCode(centerPosition, rootNode, 128);
            GD.Print("\tCaseCode: ", caseCode);


            GD.Print("\tIndices:");
            for (int i = 0; i < 18; i++)
            {
                int index = SurfaceNet.Tables.indexTable3D[caseCode, i];
                if (index == -1) break;
                GD.Print("\t", index, ", ", indices[index]);

                activeChunk.meshData.indices[indexWriteIndex] = indices[index];

                indexWriteIndex++;
            }




            // něco s floor?


        }

        // rozdělit na 2 funkce
        // -> getThisCubePart()
        // -> getNeighborCubePart()
        public void GetVertCube(ref Vector3[] vertCubePositions, ref Vector3[] vertCubeNormals, ref int[] vertCubeIndices, Octree.Node rootNode, Vector3 centerPosition)
        {
            // loop
            for (int i = 0; i < 8; i++)
            {
                // získání sample pozice
                Vector3 centerOffset = (new Vector3(i % 2, i / 4, i / 2 % 2) * 2.0f - new Vector3(1.0f, 1.0f, 1.0f)) * 0.1f; // offset pozice od centra krychle
                Vector3 samplePosition = centerPosition + centerOffset;
                // získání bodu
                Octree.Node nodeWithPos = rootNode.GetNodeWithPosition(samplePosition); // je zaručené že bude listem
                // kontrola bodu
                if (nodeWithPos == null) continue;
                if (nodeWithPos.chunkIndex == -1) continue;
                // získání vertexu
                int sampleVertIndex = GetVertIndex(nodeWithPos, samplePosition);
                Vector3 sampleVertPosition = GetRelativeVertPosition(nodeWithPos, sampleVertIndex);
                Vector3 sampleVertNormal = GetVertNormal(nodeWithPos, sampleVertIndex);
                // zapsání vertexu
                vertCubePositions[i] = sampleVertPosition;
                // zapsání normal
                vertCubeNormals[i] = sampleVertNormal;
                // zapsaní indexu
                if (nodeWithPos == this) // pokud je v aktivním chunku
                {
                    vertCubeIndices[i] = sampleVertIndex;
                }
                else // -1 pokud index je mimo aktivní chunk
                {
                    vertCubeIndices[i] = -1;
                }
            }

            // pokud je vedlejší chunk menší tak iterovat od něj?
        }
        
        public int GetVertIndex(Octree.Node nodeWithPos, Vector3 samplePosition)
        {
            // Získání pozice v Octantu
            Vector3 posInNode = samplePosition - nodeWithPos.position;
            // Získání indexu v chunku
            int chunkSize = Terrain22.Chunk.size;
            int vertFieldSize = Terrain22.Chunk.size;
            Vector3I posInChunk = (Vector3I)(posInNode / (nodeWithPos.size / chunkSize)); // MOŽNÁ ŠPATNĚ
            int vertIndex = posInChunk.X + posInChunk.Y * vertFieldSize + posInChunk.Z * vertFieldSize * vertFieldSize;
            return vertIndex;
        }

        public Vector3 GetRelativeVertPosition(Octree.Node nodeWithPos, int sampleVertIndex)
        {
            // získání chunku
            Terrain22.Chunk sampleChunk = chunkQueue.GetChunk(nodeWithPos.chunkIndex);
            // získání vertexu
            int chunkSize = Terrain22.Chunk.size;
            float scaleDiffrence = nodeWithPos.size / this.size;
            Vector3 sampleVertPosition = sampleChunk.meshData.vertexPositions[sampleVertIndex] * scaleDiffrence;
            // nastavíme relativní pozici pokud se jedná o jinej chunk
            if (nodeWithPos != this && sampleVertPosition != new Vector3(0, 0, 0))
            {
                Vector3 offset = (nodeWithPos.position - this.position) / (this.size / chunkSize); // vždy bude stejné, takže tohle nemusíme ani počítat?
                sampleVertPosition += offset;
            }
            return sampleVertPosition;
        }

        public Vector3 GetVertNormal(Octree.Node nodeWithPos, int sampleVertIndex)
        {
            // získání chunku
            Terrain22.Chunk sampleChunk = chunkQueue.GetChunk(nodeWithPos.chunkIndex);
            // získání normálu
            Vector3 sampleVertNormal = sampleChunk.meshData.vertexNormals[sampleVertIndex];
            return sampleVertNormal;
        }


        public byte GetFieldValue(Octree.Node rootNode, Vector3 samplePosition)
        {
            Octree.Node nodeWithPos = rootNode.GetNodeWithPosition(samplePosition);

            if (nodeWithPos == null)  return 0;
            if (nodeWithPos.chunkIndex == -1) return 0;

            Terrain22.Chunk sampleChunk = chunkQueue.GetChunk(nodeWithPos.chunkIndex);

            Vector3 posInNode = samplePosition - nodeWithPos.position;

            int chunkSize = Terrain22.Chunk.size;
            int fieldSize = Terrain22.Chunk.fieldSize;
            Vector3I posInChunk = (Vector3I)(posInNode / (nodeWithPos.size / chunkSize)); // MOŽNÁ ŠPATNĚ
            int fieldIndex = posInChunk.X + posInChunk.Y * fieldSize + posInChunk.Z * fieldSize * fieldSize;

            byte fieldValue = sampleChunk.field[fieldIndex];
            //
            return fieldValue;
        }

        public byte GetCaseCode(Vector3 centerPosition, Octree.Node rootNode, byte isoLevel) // neskutečně pomalé
        {
            return (byte)((GetFieldValue(rootNode, centerPosition + new Vector3(-0.1f, -0.1f, -0.1f)) > isoLevel ? 0x01 : 0)
            | (GetFieldValue(rootNode, centerPosition + new Vector3(0.1f, -0.1f, -0.1f)) > isoLevel ? 0x02 : 0)
            | (GetFieldValue(rootNode, centerPosition + new Vector3(-0.1f, -0.1f, 0.1f)) > isoLevel ? 0x04 : 0)
            | (GetFieldValue(rootNode, centerPosition + new Vector3(0.1f, -0.1f, 0.1f)) > isoLevel ? 0x08 : 0)
            // horní část krychle
            | (GetFieldValue(rootNode, centerPosition + new Vector3(-0.1f, 0.1f, -0.1f)) > isoLevel ? 0x10 : 0)
            | (GetFieldValue(rootNode, centerPosition + new Vector3(0.1f, 0.1f, -0.1f)) > isoLevel ? 0x20 : 0)
            | (GetFieldValue(rootNode, centerPosition + new Vector3(-0.1f, 0.1f, 0.1f)) > isoLevel ? 0x40 : 0)
            | (GetFieldValue(rootNode, centerPosition + new Vector3(0.1f, 0.1f, 0.1f)) > isoLevel ? 0x80 : 0));
        }
    }
}

// [07.08.2025] vytvořeno protože všechno v NodeVisual.CS je bordel