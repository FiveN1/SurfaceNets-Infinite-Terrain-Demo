using System;
using System.Reflection.Metadata.Ecma335;
using Godot;

namespace Octree
{
    public partial class Node
    {


        public void Stich2()
        {
            // pouze pro x

            if (this.position != new Vector3(0, 0, 0))
            {
                return;
            }


            int vertFieldSize = Terrain22.Chunk.size;
            int coreSectionSize = vertFieldSize * vertFieldSize * vertFieldSize;
            int sectionindex = coreSectionSize;

            for (int i = 1; i < 2; i++)
            {
                Vector3I neighborDirection = new(i % 2, i / 2 % 2, i / 4);
                GD.Print("stiching at direction:", neighborDirection);

                sectionindex += StichDirection(neighborDirection, sectionindex);
            }

        }

        /*
        * Pro StichDirection():
        * -> vytvořit sekci o velikosti
        * -> zapisovat vertexy
        * -> pokud casecube nejde out of bounds, spojit a vytvořit indexy.
        *
        * Takhle by se nemělo nic opakovat a vše by mělo proběhnout v jednom loopu
        *
        *
        */
        public int StichDirection(Vector3I direction, int sectionindex)
        {

            // za tohodle souseda vložíme nové vertexy.
            Octree.Node neighbor = this.GetNeighborReal(direction);
            if (neighbor == null) return 0;


            //if (this.chunkIndex == -1) return 0;
            //Terrain22.Chunk activeChunk = chunkPool.GetChunk(this.chunkIndex);
            GD.Print("active node:", this);
            GD.Print("neighbor node:", neighbor);

            //int sectionSize = GetSectionSize(direction, neighbor);
            //GD.Print("section size: ", sectionSize);

            //
            // Iterovat na vertexech
            //



            int sectionSize = IterateOnSubdividedPlane(direction, neighbor, sectionindex);


            GD.Print("final section size: ", sectionSize);
            // vrátíme nová index
            return sectionSize;
        }


        //
        // Section
        //

        // jednoduše spočítá velikost roviny která vzniká dotykem dvou oktantů ve směru.
        // není potřeba ani zadávat octanty, pouze směr
        public int GetVertPlaneSize(Vector3I direction)
        {
            int vertFieldSize = Terrain22.Chunk.size;
            Vector3I invDirection = new Vector3I(1, 1, 1) - direction;
            // zjistíme velikost roviny, která je tvořena dotekem octantů.
            Vector3I vertPlaneSize = invDirection * vertFieldSize + direction;
            int vertCount = vertPlaneSize.X * vertPlaneSize.Y * vertPlaneSize.Z;
            return vertCount;
        }

        public int GetAllVertPlaneSizes(Vector3I direction, Octree.Node neighbor, int vertCount)
        {
            Vector3I invDirection = new Vector3I(1, 1, 1) - direction;
            Vector3I nodePlaneSize = invDirection * 2 + direction;
            // iterujem pro každý octant který se dotýká aktivního octantu
            for (int z = 0; z < nodePlaneSize.Z; z++)
            {
                for (int y = 0; y < nodePlaneSize.Y; y++)
                {
                    for (int x = 0; x < nodePlaneSize.X; x++)
                    {
                        int leafIndex = x + y * 2 + z * 4;
                        Octree.Node leaf = neighbor.leafs[leafIndex];
                        // pokud je pod-octant rozdělen, iterujem dál
                        // jinak získáme vert plane size pomocí směru.
                        if (!leaf.isLeaf)
                        {
                            vertCount += GetAllVertPlaneSizes(direction, leaf, vertCount);
                        }
                        else
                        {
                            vertCount += GetVertPlaneSize(direction);
                        }
                    }
                }
            }
            return vertCount;
        }

        // získání velikosti sekce pro daný směr
        public int GetSectionSize(Vector3I direction, Octree.Node neighbor)
        {
            if (!neighbor.isLeaf)
            {
                return GetAllVertPlaneSizes(direction, neighbor, 0);
            }
            return GetVertPlaneSize(direction);
        }

        public int GetAllSectionSize()
        {
            // velikst všech sekcí ...
            for (int i = 1; i < 2; i++)
            {
                Vector3I neighborDirection = new(i % 2, i / 2 % 2, i / 4);

            }
            return 0;
        }



        // funkce pro získání pozice v chunku

        // funkce pro získání indexu v fieldu

        //
        // Plane iteration
        //


        // zatím tato funkce jenom získá a uloží vertexy.
        // potom to vyvynu dál
        public int IterateOnPlane(Vector3I direction, Octree.Node neighbor, int sectionIndex)
        {
            GD.Print("--- iterating on: ", neighbor);

            // pokud je soused menší ...



            int vertFieldSize = Terrain22.Chunk.size;

            // velikost roviny na které bude iterovat (rovina = část kde se body dotýkají)
            Vector3I invDirection = new Vector3I(1, 1, 1) - direction;
            Vector3I planeSize = invDirection * vertFieldSize + direction;
            int sectionSize = planeSize.X * planeSize.Y * planeSize.Z;
            GD.Print("planeSize: ", planeSize);

            // rozdíl octantů
            Vector3 posDiff = (neighbor.position - this.position) * invDirection;
            float sizeDiff = this.size / neighbor.size;
            GD.Print("posDiff: ", posDiff);
            GD.Print("sizeDiff: ", sizeDiff);

            // neighbor chunk
            if (neighbor.chunkIndex == -1) return 0;
            Terrain22.Chunk neighborChunk = chunkPool.GetChunk(neighbor.chunkIndex);
            if (this.chunkIndex == -1) return 0;
            Terrain22.Chunk activeChunk = chunkPool.GetChunk(this.chunkIndex);

            // iterate na rovině
            for (int z = 0; z < planeSize.Z; z++)
            {
                for (int y = 0; y < planeSize.Y; y++)
                {
                    for (int x = 0; x < planeSize.X; x++)
                    {
                        // pozice v sousedovi
                        Vector3 pos = new(x, y, z); // POZNÁMKA: naní pos v aktivním chunku !
                        Vector3I neighborPos = (Vector3I)(posDiff + pos * sizeDiff); // POZNÁMKA: round na floor
                        GD.Print("pos: ", pos);
                        GD.Print("neighborPos: ", neighborPos);

                        // vert
                        int neighborVertIndex = neighborPos.X + neighborPos.Y * vertFieldSize + neighborPos.Z * vertFieldSize * vertFieldSize;
                        Vector3 vertOffset = direction * vertFieldSize;
                        float vertScale = 1.0f / sizeDiff;
                        GD.Print("neighborVertIndex: ", neighborVertIndex);
                        Vector3 neighborVert = neighborChunk.meshData.vertexPositions[neighborVertIndex] * vertScale + vertOffset;
                        GD.Print("neighborVert: ", neighborVert);

                        // index v sekci
                        int inSectionIndex = x + y * planeSize.X + z * planeSize.X * planeSize.Y; // jde zjednodušit !! (pokud použijeme++)
                        int index = sectionIndex + inSectionIndex;
                        GD.Print("index: ", index);

                        // write
                        activeChunk.meshData.vertexPositions[index] = neighborVert;

                        // stich
                        // ...

                    }
                }
            }

            GD.Print("returning sectionSize:", sectionSize);
            return sectionSize;
        }

        public int IterateOnSubdividedPlane(Vector3I direction, Octree.Node neighbor, int sectionIndex)
        {
            //
            if (neighbor.isLeaf)
            {
                return IterateOnPlane(direction, neighbor, sectionIndex);
            }


            //
            int sectionSize = 0;

            //
            Vector3I invDirection = new Vector3I(1, 1, 1) - direction;
            Vector3I nodePlaneSize = invDirection * 2 + direction; // POZNÁMKA: 2 je tady proto že je to délka jedné strany krychle octantů.
            // iterujem pro každý octant který se dotýká aktivního octantu
            for (int z = 0; z < nodePlaneSize.Z; z++)
            {
                for (int y = 0; y < nodePlaneSize.Y; y++)
                {
                    for (int x = 0; x < nodePlaneSize.X; x++)
                    {
                        int leafIndex = x + y * 2 + z * 4;
                        Octree.Node leaf = neighbor.leafs[leafIndex];

                        sectionSize += IterateOnSubdividedPlane(direction, leaf, sectionIndex + sectionSize);

                    }
                }
            }

            // 
            return sectionSize;
        }
    

    }
}