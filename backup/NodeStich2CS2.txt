using System;
using System.Reflection.Metadata.Ecma335;
using Godot;

namespace Octree
{
    public partial class Node
    {


        public void Stich2()
        {
            // pouze pro x

            if (this.position != new Vector3(0, 0, 0))
            {
                return;
            }


            int vertFieldSize = Terrain22.Chunk.size;
            int coreSectionSize = vertFieldSize * vertFieldSize * vertFieldSize;
            int sectionindex = coreSectionSize;

            for (int i = 1; i < 2; i++)
            {
                Vector3I neighborDirection = new(i % 2, i / 2 % 2, i / 4);
                //GD.Print("stiching at direction:", neighborDirection);

                sectionindex += StichDirection(neighborDirection, sectionindex);
            }

        }

        /*
        * Pro StichDirection():
        * -> vytvořit sekci o velikosti
        * -> zapisovat vertexy
        * -> pokud casecube nejde out of bounds, spojit a vytvořit indexy.
        *
        * Takhle by se nemělo nic opakovat a vše by mělo proběhnout v jednom loopu
        *
        *
        */
        public int StichDirection(Vector3I direction, int sectionindex)
        {

            // získáme souseda stejné nebo větší velikosti
            Octree.Node neighbor = this.GetNeighborReal(direction);
            if (neighbor == null) return 0;
            GD.Print("active node:", this);
            GD.Print("neighbor node:", neighbor);

            // získáme všechny vertexy
            int sectionSize = IterateOnSubdividedPlane(direction, neighbor, sectionindex);
            GD.Print("final section size: ", sectionSize);

            // vrátíme nová index
            return sectionSize;
        }


        //
        // Section (tohle se používá pouze při tvorbě pole s vertexy, takže ne tady)
        //

        // jednoduše spočítá velikost roviny která vzniká dotykem dvou oktantů ve směru.
        // není potřeba ani zadávat octanty, pouze směr
        public int GetVertPlaneSize(Vector3I direction)
        {
            int vertFieldSize = Terrain22.Chunk.size;
            Vector3I invDirection = new Vector3I(1, 1, 1) - direction;
            // zjistíme velikost roviny, která je tvořena dotekem octantů.
            Vector3I vertPlaneSize = invDirection * vertFieldSize + direction;
            int vertCount = vertPlaneSize.X * vertPlaneSize.Y * vertPlaneSize.Z;
            return vertCount;
        }

        public int GetAllVertPlaneSizes(Vector3I direction, Octree.Node neighbor, int vertCount)
        {
            Vector3I invDirection = new Vector3I(1, 1, 1) - direction;
            Vector3I nodePlaneSize = invDirection * 2 + direction;
            // iterujem pro každý octant který se dotýká aktivního octantu
            for (int z = 0; z < nodePlaneSize.Z; z++)
            {
                for (int y = 0; y < nodePlaneSize.Y; y++)
                {
                    for (int x = 0; x < nodePlaneSize.X; x++)
                    {
                        int leafIndex = x + y * 2 + z * 4;
                        Octree.Node leaf = neighbor.leafs[leafIndex];
                        // pokud je pod-octant rozdělen, iterujem dál
                        // jinak získáme vert plane size pomocí směru.
                        if (!leaf.isLeaf)
                        {
                            vertCount += GetAllVertPlaneSizes(direction, leaf, vertCount);
                        }
                        else
                        {
                            vertCount += GetVertPlaneSize(direction);
                        }
                    }
                }
            }
            return vertCount;
        }

        // získání velikosti sekce pro daný směr
        public int GetSectionSize(Vector3I direction, Octree.Node neighbor)
        {
            if (!neighbor.isLeaf)
            {
                return GetAllVertPlaneSizes(direction, neighbor, 0);
            }
            return GetVertPlaneSize(direction);
        }

        public int GetAllSectionSize()
        {
            // velikst všech sekcí ...
            for (int i = 1; i < 2; i++)
            {
                Vector3I neighborDirection = new(i % 2, i / 2 % 2, i / 4);

            }
            return 0;
        }



        // funkce pro získání pozice v chunku

        // funkce pro získání indexu v fieldu

        //
        // Plane iteration
        //


        // zatím tato funkce jenom získá a uloží vertexy.
        // potom to vyvynu dál
        public int IterateOnPlane(Vector3I direction, Octree.Node neighbor, int sectionIndex)
        {
            GD.Print("--- iterating on: ", neighbor);

            int vertFieldSize = Terrain22.Chunk.size;

            // velikost roviny na které bude iterovat (rovina = část kde se body dotýkají)
            Vector3I invDirection = new Vector3I(1, 1, 1) - direction;
            Vector3I planeSize = invDirection * vertFieldSize + direction;
            int sectionSize = planeSize.X * planeSize.Y * planeSize.Z;
            GD.Print("planeSize: ", planeSize);

            // rozdíl octantů
            Vector3 posDiff = (neighbor.position - this.position) * invDirection;
            float sizeDiff = this.size / neighbor.size;
            GD.Print("posDiff: ", posDiff);
            GD.Print("sizeDiff: ", sizeDiff);

            // neighbor chunk
            if (neighbor.chunkIndex == -1) return 0;
            Terrain22.Chunk neighborChunk = chunkPool.GetChunk(neighbor.chunkIndex);
            if (this.chunkIndex == -1) return 0;
            Terrain22.Chunk activeChunk = chunkPool.GetChunk(this.chunkIndex);

            // iterate na rovině
            for (int z = 0; z < planeSize.Z; z++)
            {
                for (int y = 0; y < planeSize.Y; y++)
                {
                    for (int x = 0; x < planeSize.X; x++)
                    {
                        // pozice v sousedovi
                        Vector3 pos = new(x, y, z); // POZNÁMKA: naní pos v aktivním chunku !
                        Vector3I neighborPos = (Vector3I)pos;
                        if (neighbor.size > this.size) // pokud je soused větší, musíme scalenout sample indexy. (protože iterujeme na menším)
                        {
                            neighborPos = (Vector3I)(posDiff + pos * sizeDiff); // POZNÁMKA: round na floor
                        }
                        GD.Print("\tpos: ", pos);
                        GD.Print("\tneighborPos: ", neighborPos);

                        // vert
                        int neighborVertIndex = neighborPos.X + neighborPos.Y * vertFieldSize + neighborPos.Z * vertFieldSize * vertFieldSize;
                        Vector3 vertOffset = direction * vertFieldSize;
                        float vertScale = 1.0f / sizeDiff;
                        GD.Print("\tneighborVertIndex: ", neighborVertIndex);
                        Vector3 neighborVert = neighborChunk.meshData.vertexPositions[neighborVertIndex] * vertScale + vertOffset;
                        GD.Print("\tneighborVert: ", neighborVert);

                        // index v sekci
                        int inSectionIndex = x + y * planeSize.X + z * planeSize.X * planeSize.Y; // jde zjednodušit !! (pokud použijeme++)
                        int index = sectionIndex + inSectionIndex;
                        GD.Print("\tindex: ", index);

                        // write
                        activeChunk.meshData.vertexPositions[index] = neighborVert;

                        // stich
                        // ...
                        // tohle bude peklo


                        // získat všechny chunky které se dotýkají

                        // pro každý roh:
                        // -> zjistit do jaké sekce patří.
                        // -> najít index v sekci - nějaká funkce? - sample position relativní k sekci. - iteruje se pokud je dělená.
                        // -> zapsat

                        // TADY POKRAČOVAT ! vvv

                        // ? pokud je direction složený tak vrátit

                        // tohle asi odstranit...
                        if (direction != new Vector3I(1, 0, 0))
                        {
                            continue;
                        }

                        if (y >= planeSize.Y - 1 || z >= planeSize.Z - 1)
                        {
                            continue;
                        }

                        GD.Print("STICHING: ", pos);

                        // stich mezi 2 chunky

                        






                    }
                }
            }

            // tady pokračovat pro všechny strany v rovině.
            // ... spoj s vedlejšími chunky
            // ...

            GD.Print("returning sectionSize: ", sectionSize, "\n");
            return sectionSize;
        }


        public int IterateOnSubdividedPlane(Vector3I direction, Octree.Node neighbor, int sectionIndex)
        {
            // pokud octant není rozdělen, iterujem na jeho rovině.
            if (neighbor.isLeaf)
            {
                return IterateOnPlane(direction, neighbor, sectionIndex);
            }
            // pokud ale je rozdělen iterujeme na každé rovině jeho listů.
            // velikost sekce je součtem všech sekcí listů
            int sectionSize = 0;
            // získáme listy které se dotýkají s aktivním octantem
            Vector3I invDirection = new Vector3I(1, 1, 1) - direction;
            Vector3I nodePlaneSize = invDirection * 2 + direction; // POZNÁMKA: 2 je tady proto že je to délka jedné strany krychle octantů.
            // iterujem pro každý octant který se dotýká aktivního octantu
            for (int z = 0; z < nodePlaneSize.Z; z++)
            {
                for (int y = 0; y < nodePlaneSize.Y; y++)
                {
                    for (int x = 0; x < nodePlaneSize.X; x++)
                    {
                        int leafIndex = x + y * 2 + z * 4;
                        Octree.Node leaf = neighbor.leafs[leafIndex];

                        sectionSize += IterateOnSubdividedPlane(direction, leaf, sectionIndex + sectionSize);

                    }
                }
            }
            // vrátíme součet všech sekcí
            return sectionSize;
        }


        public void Stich(Vector3I direction)
        {
            
        }

    }
}