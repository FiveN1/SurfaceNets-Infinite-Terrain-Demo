using Godot;
using System;

// čistší implementace octree systému

// ZMENŠIT CHUNK NA  3X3 NEBO 2X2

namespace Octree
{
    public partial class Node
    {

        public static bool debugVisualsEnabled = false;
        static Node3D meshNode;
        static StandardMaterial3D debugMeshMaterial;
        MeshInstance3D debugBox;

        static ChunkQueue chunkQueue;

        int chunkIndex = -1;

        public void CreateMesh()
        {

            /*
            * Pipeline
            *
            * octNode {node v octree}
            * fieldData {3D byte data}
            * meshData {vertices, normals, indices}
            * -> vertices [core vertices...end] [end...edge vertices]
            *
            * GetEdgeField(octNode)
            *
            * GenerateMeshCore(fieldData, meshData)
            *
            * GetEdgeVertices(octNode, meshData)
            *
            * CreateEdgeIndices(fieldData, meshData)
            *
            *
            */


            //if (!debugVisualsEnabled) return;
            //if (this.debugBox != null) return;

            if (chunkIndex != -1) return;


            /*
            BoxMesh boxMesh = new BoxMesh();
            boxMesh.Size = new Vector3(this.size, this.size, this.size);
            this.debugBox = new MeshInstance3D();
            this.debugBox.Mesh = boxMesh;
            this.debugBox.Position = this.position + new Vector3(this.size, this.size, this.size) * 0.5f;
            //StandardMaterial3D MeshMaterial = NodeMaterial.Duplicate() as StandardMaterial3D;
            //MeshMaterial.AlbedoColor = new Color((GD.Randi() % 100) * 0.01f, (GD.Randi() % 100) * 0.01f, (GD.Randi() % 100) * 0.01f, 0.2f);
            this.debugBox.SetSurfaceOverrideMaterial(0, debugMeshMaterial);
            meshNode.AddChild(this.debugBox);
            */

            //
            // Get chunk
            //
            chunkIndex = chunkQueue.GetAvalibeChunk();
            //GD.Print("found avalible chunk at: ", chunkIndex);
            //
            Terrain22.Chunk chunk = chunkQueue.GetChunk(chunkIndex);
            chunk.LoadField(Octree.Tree.worldGen, this.size, this.position);


            //
            // get neighbor data
            //
            // Pro každý direction (0, 0, 0) - (1, 1, 1), 0 - 7
            //
            //

            if (this.position == new Vector3(0, 0, 0))
            {
                GD.Print("GENERATING CHUNK EDGE");
                for (int i = 1; i < 8; i++)
                {
                    //Vector3I NeighborDirection = new(i % 2, i / 2 % 2, i / 4);
                    //GD.Print("Neighbor Direction: ", NeighborDirection);

                    //GetEdgeFieldValues(NeighborDirection, ref chunk.field, Terrain22.Chunk.fieldSize);
                }

                Vector3I NeighborDirection = new(1, 0, 0);

                Octree.Node neighborNode = this.GetNeighbor(NeighborDirection);
                if (neighborNode != null)
                {
                    if (neighborNode.chunkIndex != -1 || neighborNode.size == this.size)
                    {
                        Terrain22.Chunk neighborChunk = chunkQueue.GetChunk(neighborNode.chunkIndex);
                        Terrain22.Chunk thisChunk = chunkQueue.GetChunk(this.chunkIndex);
                        int edgeVertindex = Terrain22.Chunk.size * Terrain22.Chunk.size * Terrain22.Chunk.size;
                        int edgeIndexindex = Terrain22.Chunk.size * Terrain22.Chunk.size * Terrain22.Chunk.size * 18;

                        GD.Print("...");
                        GetEdgeFieldValues(thisChunk, neighborChunk);
                        GD.Print("...");
                        GetEdgeVertices(thisChunk, neighborChunk, edgeVertindex, neighborNode.position);
                        GD.Print("...");
                        GetEdgeIndices(thisChunk, neighborChunk, edgeVertindex, edgeIndexindex);
                        GD.Print("...");
                    }
                }
            }


            chunk.GenerateMesh(this.size, this.position);
            // load at position
            // make mesh


        }


        public void RemoveMesh()
        {
            if (chunkIndex == -1) return;
            /*
            if (!debugVisualsEnabled) return;
            if (this.debugBox == null) return;

            meshNode.RemoveChild(this.debugBox);
            this.debugBox.QueueFree();
            this.debugBox = null;
            */

            chunkQueue.MakeChunkavalible(chunkIndex);
            chunkIndex = -1;

        }

        public static void EnableDebugVisuals(bool enabled)
        {
            debugVisualsEnabled = enabled;
        }

        public static void SetMeshParentNode(Node3D meshParentNode)
        {
            meshNode = meshParentNode;
        }

        public static void SetDebugMeshMaterial(StandardMaterial3D material)
        {
            debugMeshMaterial = material;
        }

        public static void SetChunkQueue(ChunkQueue chunkQueueInstance)
        {
            chunkQueue = chunkQueueInstance;
        }


        //
        // CHUNK EDGE CONNECT
        //



        void GetEdgeFieldValues(Terrain22.Chunk activeChunk, Terrain22.Chunk neighborChunk)
        {
            int fieldSize = Terrain22.Chunk.fieldSize;

            for (int z = 0; z < fieldSize; z++)
            {
                for (int y = 0; y < fieldSize; y++)
                {
                    int thisIndex = (fieldSize - 1) + y * fieldSize + z * fieldSize * fieldSize;
                    int nextIndex = y * fieldSize + z * fieldSize * fieldSize;

                    activeChunk.field[thisIndex] = neighborChunk.field[nextIndex];
                    GD.Print("set field at: ", thisIndex, " to: ", neighborChunk.field[nextIndex]);
                }
            }

        }

        void GetEdgeVertices(Terrain22.Chunk activeChunk, Terrain22.Chunk neighborChunk, int edgeVErticesStartindex, Vector3 neighborNodePosition)
        {
            int fieldSize = Terrain22.Chunk.fieldSize;
            int vertfieldSize = Terrain22.Chunk.size;
            
            for (int z = 0; z < vertfieldSize; z++)
            {
                for (int y = 0; y < vertfieldSize; y++)
                {
                    int nextVertIndex = y * vertfieldSize + z * vertfieldSize * vertfieldSize;

                    activeChunk.meshData.vertexPositions[edgeVErticesStartindex + nextVertIndex] = neighborChunk.meshData.vertexPositions[nextVertIndex] + neighborNodePosition;
                    GD.Print("Added vertex: ", neighborChunk.meshData.vertexPositions[nextVertIndex], " at: ", edgeVErticesStartindex + nextVertIndex);
                }
            }
        }

        void GetEdgeIndices(Terrain22.Chunk activeChunk, Terrain22.Chunk neighborChunk, int edgeVErticesStartindex, int edgeIndicesStartIndex)
        {

            int fieldSize = Terrain22.Chunk.fieldSize;
            int vertfieldSize = Terrain22.Chunk.size;

            int writeIndex = edgeIndicesStartIndex;

            for (int z = 0; z < vertfieldSize; z++)
            {
                for (int y = 0; y < vertfieldSize; y++)
                {
                    int thisFieldIndex = (vertfieldSize - 1) + y * fieldSize + z * fieldSize * fieldSize;
                    int thisVertIndex = (vertfieldSize - 1) + y * vertfieldSize + z * vertfieldSize * vertfieldSize;
                    int nextVertIndex = y * vertfieldSize + z * vertfieldSize * vertfieldSize;

                    int caseCode = SurfaceNet.Algorithm.GetCaseCode(ref activeChunk.field, new(fieldSize, fieldSize, fieldSize), 128, thisFieldIndex);

                    //GD.Print("Added index: ", thisVertIndex, " caseCode: ", caseCode, " thisFieldIndex: ", thisFieldIndex);

                    for (int i = 0; i < 18; i++)
                    {
                        int index = SurfaceNet.Tables.indexTable3D[caseCode, i];
                        if (index == -1) break;
                        Vector3I indexV = new(index % 2, index / 4, index / 2 % 2);

                        if (indexV.X == 1)
                        {
                            activeChunk.meshData.indices[writeIndex] = edgeVErticesStartindex + nextVertIndex + indexV.Y * vertfieldSize + indexV.Z * vertfieldSize * vertfieldSize;
                        }
                        else
                        {
                            activeChunk.meshData.indices[writeIndex] = thisVertIndex + indexV.Y * vertfieldSize + indexV.Z * vertfieldSize * vertfieldSize;
                        }

                        GD.Print("index: ", activeChunk.meshData.indices[writeIndex]);
                        
                        writeIndex++;
                    }
                }
            }
        }


        
    }
}