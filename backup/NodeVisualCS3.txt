using Godot;
using System;

// čistší implementace octree systému

// ZMENŠIT CHUNK NA  3X3 NEBO 2X2

namespace Octree
{
    public partial class Node
    {

        public static bool debugVisualsEnabled = false;
        static Node3D meshNode;
        static StandardMaterial3D debugMeshMaterial;
        MeshInstance3D debugBox;

        static ChunkQueue chunkQueue;

        int chunkIndex = -1;

        public void CreateMesh()
        {

            /*
            * Pipeline
            *
            * octNode {node v octree}
            * fieldData {3D byte data}
            * meshData {vertices, normals, indices}
            * -> vertices [core vertices...end] [end...edge vertices]
            *
            * GetEdgeField(octNode)
            *
            * GenerateMeshCore(fieldData, meshData)
            *
            * GetEdgeVertices(octNode, meshData)
            *
            * CreateEdgeIndices(fieldData, meshData)
            *
            *
            */


            //if (!debugVisualsEnabled) return;
            //if (this.debugBox != null) return;

            if (chunkIndex != -1) return;


            /*
            BoxMesh boxMesh = new BoxMesh();
            boxMesh.Size = new Vector3(this.size, this.size, this.size);
            this.debugBox = new MeshInstance3D();
            this.debugBox.Mesh = boxMesh;
            this.debugBox.Position = this.position + new Vector3(this.size, this.size, this.size) * 0.5f;
            //StandardMaterial3D MeshMaterial = NodeMaterial.Duplicate() as StandardMaterial3D;
            //MeshMaterial.AlbedoColor = new Color((GD.Randi() % 100) * 0.01f, (GD.Randi() % 100) * 0.01f, (GD.Randi() % 100) * 0.01f, 0.2f);
            this.debugBox.SetSurfaceOverrideMaterial(0, debugMeshMaterial);
            meshNode.AddChild(this.debugBox);
            */

            //
            // Get chunk
            //
            chunkIndex = chunkQueue.GetAvalibeChunk();
            //GD.Print("found avalible chunk at: ", chunkIndex);
            //
            Terrain22.Chunk chunk = chunkQueue.GetChunk(chunkIndex);
            for (int i = 0; i < chunk.field.Length; i++)
            {
                chunk.field[i] = 0;
            }
            chunk.LoadField(Octree.Tree.worldGen, this.size, this.position);


            //
            // get neighbor data
            //
            // Pro každý direction (0, 0, 0) - (1, 1, 1), 0 - 7
            //
            //
            // DĚLÁM TO VŠECHNO ŠPATNĚ!!
            // SPOJIT VERTEXY LZE I POUZE NA ZÁKLADĚ INFORMACÍ Z VERTEXU !!
            // takže edge by šel i na GPU



            /*
            Vector3I neighborDirection = new(1, 0, 0);
            // Teď Pro všechny strany
            Octree.Node neighborNode = this.GetNeighbor(neighborDirection);
            if (neighborNode != null)
            {
                if (neighborNode.chunkIndex != -1 || neighborNode.size == this.size)
                {
                    Terrain22.Chunk neighborChunk = chunkQueue.GetChunk(neighborNode.chunkIndex);
                    Terrain22.Chunk thisChunk = chunkQueue.GetChunk(this.chunkIndex);
                    int edgeVertindex = Terrain22.Chunk.size * Terrain22.Chunk.size * Terrain22.Chunk.size;
                    int edgeIndexindex = Terrain22.Chunk.size * Terrain22.Chunk.size * Terrain22.Chunk.size * 18;

                    GD.Print("...");
                    GetEdgeFieldValues(thisChunk, neighborChunk, neighborDirection);
                    GD.Print("...");
                    GetEdgeVertices(thisChunk, neighborChunk, edgeVertindex, neighborNode.position, neighborDirection);
                    GD.Print("...");
                    GetEdgeIndices(thisChunk, edgeVertindex, edgeIndexindex, neighborDirection);
                    GD.Print("...");
                }
            }
            */

            //StichChunks();


            //chunk.GenerateMesh(this.size, this.position);
            GenerateChunkMesh(chunk);
            // load at position
            // make mesh

            //StichChunks();


        }


        public void RemoveMesh()
        {
            if (chunkIndex == -1) return;
            /*
            if (!debugVisualsEnabled) return;
            if (this.debugBox == null) return;

            meshNode.RemoveChild(this.debugBox);
            this.debugBox.QueueFree();
            this.debugBox = null;
            */

            chunkQueue.MakeChunkavalible(chunkIndex);
            chunkIndex = -1;

        }

        public static void EnableDebugVisuals(bool enabled)
        {
            debugVisualsEnabled = enabled;
        }

        public static void SetMeshParentNode(Node3D meshParentNode)
        {
            meshNode = meshParentNode;
        }

        public static void SetDebugMeshMaterial(StandardMaterial3D material)
        {
            debugMeshMaterial = material;
        }

        public static void SetChunkQueue(ChunkQueue chunkQueueInstance)
        {
            chunkQueue = chunkQueueInstance;
        }


        //
        // CHUNK EDGE CONNECT
        //

        void GenerateChunkMesh(Terrain22.Chunk chunk)
        {

            //GD.Print("generated mesh for node at: ", this.position);

            int fieldSize = Terrain22.Chunk.fieldSize;
            int chunkSize = Terrain22.Chunk.size;

            GetEdgeFieldValues();

            SurfaceNet.Algorithm.GenerateMeshData2(ref chunk.field, new(fieldSize, fieldSize, fieldSize), 128, ref chunk.meshData, new(fieldSize - 1, fieldSize - 1, fieldSize - 1));

            //StichChunks();

            Godot.ArrayMesh arrayMesh = new Godot.ArrayMesh();
            Godot.Collections.Array arrays = [];
            arrays.Resize((int)Mesh.ArrayType.Max);
            arrays[(int)Mesh.ArrayType.Vertex] = chunk.meshData.vertexPositions;
            arrays[(int)Mesh.ArrayType.Normal] = chunk.meshData.vertexNormals;
            arrays[(int)Mesh.ArrayType.Index] = chunk.meshData.indices;

            arrayMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, arrays);
            chunk.surfaceNetMesh.Mesh = arrayMesh;
            chunk.surfaceNetMesh.Position = this.position;
            chunk.surfaceNetMesh.Scale = new Vector3(this.size, this.size, this.size) * (1.0f / (float)chunkSize); // ((float)FieldSize - 2.0f)
        }

        void StichChunks()
        {
            //GD.Print("GENERATING CHUNK EDGE");

            if (this.position != new Vector3(0, 0, 0))
            {
                //return;
            }

            if (this.size != 16)
            {
                //return;
            }
            //GD.Print("stiching big chunk");

            for (int i = 1; i < 8; i++)
            {
                Vector3I neighborDirection = new(i % 2, i / 2 % 2, i / 4);
                //GD.Print("Neighbor Direction: ", NeighborDirection);
                Octree.Node neighborNode = this.GetNeighbor(neighborDirection);
                if (neighborNode == null) continue;
                if (neighborNode.chunkIndex == -1 || neighborNode.size != this.size) continue;

                Terrain22.Chunk neighborChunk = chunkQueue.GetChunk(neighborNode.chunkIndex);
                Terrain22.Chunk thisChunk = chunkQueue.GetChunk(this.chunkIndex);
                int neighborVertBegin = GetVertexStart(i);
                int neighborIndexBegin = neighborVertBegin * 18;

                //GD.Print("Vert begin index: ", neighborVertBegin);

                //GD.Print("...");
                //GetEdgeFieldValues(thisChunk, neighborChunk, neighborDirection, neighborNode);
                //GD.Print("...");
                GetEdgeVertices(thisChunk, neighborChunk, neighborVertBegin, neighborNode.position - this.position, neighborDirection);
                //GD.Print("...");
                GetEdgeIndices(thisChunk, neighborVertBegin, neighborIndexBegin, neighborDirection);
                //GD.Print("...");

                //GetEdgeVertices2(thisChunk, neighborChunk, neighborVertBegin, neighborNode.position - this.position, neighborDirection);
                //GD.Print("neighbor chunk: ", neighborNode.position);
            }
                
        }

        void GetEdgeFieldValues()
        {
            Octree.Node rootNode = this.GetRootNode();
            // chyba v hledání souseda!!
            // radši pro začátek traversnout celý strom
            for (int i = 1; i < 8; i++)
            {


                Vector3I neighborDirection = new(i % 2, i / 2 % 2, i / 4);
                Octree.Node neighborNode = this.GetNeighbor(neighborDirection);

                if (neighborNode == null) continue;

                Terrain22.Chunk thisChunk = chunkQueue.GetChunk(this.chunkIndex);

                GetEdgeFieldValues(thisChunk, neighborDirection, neighborNode);
            }
        }

        void GetEdgeFieldValues(Terrain22.Chunk activeChunk, Vector3I neighborDirection, Octree.Node neighborNode)
        {
            GD.Print("edge for: ", this.position, " neighbor: ", neighborNode.position);
            int fieldSize = Terrain22.Chunk.fieldSize;

            Vector3 planeBetweenChunks = new Vector3(fieldSize - 1, fieldSize - 1, fieldSize - 1) * (new Vector3(1, 1, 1) - neighborDirection) + new Vector3(1, 1, 1);

            for (int z = 0; z < planeBetweenChunks.Z; z++)
            {
                for (int y = 0; y < planeBetweenChunks.Y; y++)
                {
                    for (int x = 0; x < planeBetweenChunks.X; x++)
                    {
                        int thisIndex = (x + (fieldSize - 1) * neighborDirection.X) + (y + (fieldSize - 1) * neighborDirection.Y) * fieldSize + (z + (fieldSize - 1) * neighborDirection.Z) * fieldSize * fieldSize;
                        int nextIndex = x + y * fieldSize + z * fieldSize * fieldSize;

                        byte fieldValue = neighborNode.GetValue((Vector3I)(this.position + new Vector3I(x + (fieldSize - 1) * neighborDirection.X, y + (fieldSize - 1) * neighborDirection.Y, z + (fieldSize - 1) * neighborDirection.Z)));
                        activeChunk.field[thisIndex] = fieldValue;
                    }
                }
            }

        }
        

        void GetEdgeVertices(Terrain22.Chunk activeChunk, Terrain22.Chunk neighborChunk, int edgeVErticesStartindex, Vector3 neighborNodePosition, Vector3I neighborDirection)
        {
            int fieldSize = Terrain22.Chunk.fieldSize;
            int vertfieldSize = Terrain22.Chunk.size;

            Vector3 planeBetweenChunks = new Vector3(vertfieldSize - 1, vertfieldSize - 1, vertfieldSize - 1) * (new Vector3(1, 1, 1) - neighborDirection) + new Vector3(1, 1, 1);



            //
            // nevejde do array!! jelikož se to bere pořád jako kostka
            //
            for (int z = 0; z < planeBetweenChunks.Z; z++)
            {
                for (int y = 0; y < planeBetweenChunks.Y; y++)
                {
                    for (int x = 0; x < planeBetweenChunks.X; x++)
                    {
                        int neighborVertIndex = x + y * vertfieldSize + z * vertfieldSize * vertfieldSize;

                        Vector3 offset = neighborDirection * vertfieldSize; // pozice na edge
                        activeChunk.meshData.vertexPositions[edgeVErticesStartindex + neighborVertIndex] = neighborChunk.meshData.vertexPositions[neighborVertIndex] + offset;
                        //activeChunk.meshData.vertexNormals[edgeVErticesStartindex + nextVertIndex] = neighborChunk.meshData.vertexNormals[nextVertIndex];
                        //GD.Print("Added vertex: ", neighborChunk.meshData.vertexPositions[neighborVertIndex], " at: ", edgeVErticesStartindex + neighborVertIndex);
                    }
                }
            }
        }

        void GetEdgeIndices(Terrain22.Chunk activeChunk, int edgeVErticesStartindex, int edgeIndicesStartIndex, Vector3I neighborDirection)
        {

            int fieldSize = Terrain22.Chunk.fieldSize;
            int vertfieldSize = Terrain22.Chunk.size;

            int writeIndex = edgeIndicesStartIndex;

            Vector3 planeBetweenChunks = new Vector3(vertfieldSize - 1, vertfieldSize - 1, vertfieldSize - 1) * (new Vector3(1, 1, 1) - neighborDirection) + new Vector3(1, 1, 1);

            for (int z = 0; z < planeBetweenChunks.Z; z++)
            {
                for (int y = 0; y < planeBetweenChunks.Y; y++)
                {
                    for (int x = 0; x < planeBetweenChunks.X; x++)
                    {
                        int thisFieldIndex = x + (vertfieldSize - 1) * neighborDirection.X + (y + (vertfieldSize - 1) * neighborDirection.Y) * fieldSize + (z + (vertfieldSize - 1) * neighborDirection.Z) * fieldSize * fieldSize;
                        int thisVertIndex = x + (vertfieldSize - 1) * neighborDirection.X + (y + (vertfieldSize - 1) * neighborDirection.Y) * vertfieldSize + (z + (vertfieldSize - 1) * neighborDirection.Z) * vertfieldSize * vertfieldSize;



                        int caseCode = SurfaceNet.Algorithm.GetCaseCode(ref activeChunk.field, new(fieldSize, fieldSize, fieldSize), 128, thisFieldIndex);

                        if (caseCode == 0 || caseCode == 255) continue;
                        //GD.Print("Added index: ", thisVertIndex, " caseCode: ", caseCode, " thisFieldIndex: ", thisFieldIndex);
                        //if (neighborDirection != new Vector3I(1, 0, 0)) continue;
                        for (int i = 0; i < 18; i++)
                        {
                            int index = SurfaceNet.Tables.indexTable3D[caseCode, i];
                            if (index == -1) break;
                            Vector3I indexV = new(index % 2, index / 4, index / 2 % 2);

                            // check zda vektor nemíří mimo chunk...
                            //
                            // DODĚLÁVÁ SE!!
                            // Vše ostatní se pak musí taky dodělat ale nejdřív je duležité mít funkční základ, potom optimalizovat.

                            // index vertexu v core array
                            //int vertIndex = thisVertIndex + indexV.X + indexV.Y * vertfieldSize + indexV.Z * vertfieldSize * vertfieldSize;
                            //Vector3I inverseDirection = new Vector3I(1, 1, 1) - neighborDirection;
                            //Vector3I planeIndex = new(x, y, z);
                            int neighborVertIndex = (x * (1 - neighborDirection.X)) + y * (1 - neighborDirection.Y) * vertfieldSize + z * (1 - neighborDirection.Z) * vertfieldSize * vertfieldSize;



                            int beginIndex = thisVertIndex;

                            // index vertexu v +x array
                            if (indexV.X == 1 && planeBetweenChunks.X == 1 || indexV.Y == 1 && planeBetweenChunks.Y == 1 || indexV.Z == 1 && planeBetweenChunks.Z == 1)
                            {
                                beginIndex = edgeVErticesStartindex + neighborVertIndex;
                            }
                            int dirrectionOffset = indexV.X * (1 - neighborDirection.X) + indexV.Y * (1 - neighborDirection.Y) * vertfieldSize + indexV.Z * (1 - neighborDirection.Z) * vertfieldSize * vertfieldSize;
                            int vertIndex = beginIndex + dirrectionOffset;
                            activeChunk.meshData.indices[writeIndex] = vertIndex;

                            //GD.Print("index: ", vertIndex, ", ", indexV, ", neighborVertIndex: ", neighborVertIndex, "... ", y * vertfieldSize + z * vertfieldSize * vertfieldSize);

                            writeIndex++;
                            

                            /*
                            if (indexV.X == 1 && neighborDirection.X == 1)
                            {
                                activeChunk.meshData.indices[writeIndex] = edgeVErticesStartindex + nextVertIndex + indexV.Y * vertfieldSize + indexV.Z * vertfieldSize * vertfieldSize;
                            }
                            else
                            {
                                activeChunk.meshData.indices[writeIndex] = thisVertIndex + indexV.Y * vertfieldSize + indexV.Z * vertfieldSize * vertfieldSize;
                            }
                            */

                        }
                    }
                }
            }
        }
        
        void GetEdgeVertices2(Terrain22.Chunk activeChunk, Terrain22.Chunk neighborChunk, int edgeVErticesStartindex, Vector3 neighborNodePosition, Vector3I neighborDirection)
        {
            int fieldSize = Terrain22.Chunk.fieldSize;
            int vertfieldSize = Terrain22.Chunk.size;

            Vector3I planeBetweenChunks = new Vector3I(vertfieldSize - 1, vertfieldSize - 1, vertfieldSize - 1) * (new Vector3I(1, 1, 1) - neighborDirection) + new Vector3I(1, 1, 1);


            // Plán iterace číslo 2
            // - pro každý vertex  na hraně chunku.
            // - podle směru indexu zjistit s jakých vertexem spojit.
            // * vertexy budou už předem uloženy stejně jako v předchozí iteraci.
            //

            //GD.Print("plane size: ", planeBetweenChunks);

            int planeSize = planeBetweenChunks.X * planeBetweenChunks.Y * planeBetweenChunks.Z;

            for (int i = 0; i < planeSize; i++)
            {
                //...
            }

            for (int z = 0; z < planeBetweenChunks.Z; z++)
            {
                for (int y = 0; y < planeBetweenChunks.Y; y++)
                {
                    for (int x = 0; x < planeBetweenChunks.X; x++)
                    {
                        //int neighborVertIndex = x + y * vertfieldSize + z * vertfieldSize * vertfieldSize;

                        //activeChunk.meshData.vertexPositions[edgeVErticesStartindex + neighborVertIndex] = neighborChunk.meshData.vertexPositions[neighborVertIndex] + neighborNodePosition;
                        //activeChunk.meshData.vertexNormals[edgeVErticesStartindex + nextVertIndex] = neighborChunk.meshData.vertexNormals[nextVertIndex];
                        //GD.Print("Added vertex: ", neighborChunk.meshData.vertexPositions[neighborVertIndex], " at: ", edgeVErticesStartindex + neighborVertIndex);
                    }
                }
            }
        }

        public byte GetValue(Vector3I point)
        {
            // získat hodnotu v bodě.
            /*
            if (this.position > point || this.position + new Vector3(this.size, this.size, this.size) < point)
            {
                GD.Print("point out of bouonds");
                return 0;
            }
            */

            if (!this.IsInside(point))
            {
                //GD.Print("point out of bouonds");
                return 0;
            }

            if (!this.isLeaf)
            {
                GD.Print("not leaf: ", this.position);
                for (int leafIndex = 0; leafIndex < 8; leafIndex++)
                {
                    Octree.Node leaf = this.leafs[leafIndex];
                    // aby nevrátil 0 tak se udělá check
                    if (leaf.IsInside(point))
                    {
                        return this.leafs[leafIndex].GetValue(point);
                    }
                }
            }


            Vector3 localPosition = point - this.position;
            // scale...
            Vector3I scalePosition = (Vector3I)((localPosition / this.size) * Terrain22.Chunk.size); // od 0.0f do 1.0f
            int indexInField = scalePosition.X + scalePosition.Y * Terrain22.Chunk.fieldSize + scalePosition.Z * Terrain22.Chunk.fieldSize * Terrain22.Chunk.fieldSize;




            if (this.chunkIndex == -1)
            {
                return 0;
            }
            Terrain22.Chunk chunk = chunkQueue.GetChunk(this.chunkIndex);
            if (indexInField >= chunk.field.Length || indexInField < 0)
            {
                GD.PrintErr("index out of range");
                GD.Print("position in field: ", scalePosition, " index: ", indexInField, " chunk position: ", this.position);
                GD.Print("input point: ", point);
                GD.Print("chunk position: ", this.position);
                GD.Print("chunk size: ", this.size);
                GD.Print("scalePosition: ", scalePosition);
            }
            byte fieldValue = chunk.field[indexInField];

            //GD.Print("position in field: ", scalePosition, " index: ", indexInField, " chunk position: ", this.position);
            return fieldValue;
        }

        int GetVertexStart(int direction)
        {

            

            int vertexFieldSize = Terrain22.Chunk.size;
            //int vertexBeginIndex = 0;


            return vertexFieldSize * vertexFieldSize * vertexFieldSize * direction;

            /*
            if (direction > 0)
            {
                vertexBeginIndex += vertexFieldSize * vertexFieldSize * vertexFieldSize;
            }
            if (direction > 1)
            {
                vertexBeginIndex += vertexFieldSize * vertexFieldSize;
            }
            if (direction > 2)
            {
                vertexBeginIndex += vertexFieldSize * vertexFieldSize;
            }
            if (direction > 3)
            {
                vertexBeginIndex += vertexFieldSize;
            }
            if (direction > 4)
            {
                vertexBeginIndex += vertexFieldSize * vertexFieldSize;
            }
            if (direction > 5)
            {
                vertexBeginIndex += vertexFieldSize;
            }
            if (direction > 6)
            {
                vertexBeginIndex += vertexFieldSize;
            }
            if (direction > 7)
            {
                vertexBeginIndex += 1; // nepoužívané
            }
            return vertexBeginIndex;
            */
        }
        
    }
}