using Godot;
using System;

namespace SurfaceNet
{

    public static class Algorithm
    {

        public static void GenerateMesh2D(ref byte[] field, Vector2I fieldSize, byte isoLevel)
        {
            // pro každou buňku v poli zjistíme vertex.
            for (int y = 0; y < fieldSize.Y - 1; y++)
            {
                for (int x = 0; x < fieldSize.X - 1; x++)
                {
                    // zjistíme o jakou konfiguraci se jedná pomocí table (velmi rychlé)
                    byte caseCode = GetCaseCode2D(ref field, fieldSize, x, y, isoLevel);
                    // pokud se jedná o prázdnou konfiguraci tak pokračujem dál na další buňku.
                    if (caseCode == 0 || caseCode == 16)
                    {
                        continue;
                    }
                    // zjistníme pozici vertexu v buňce.
                    Vector2 vertexPosition = GetVertexPosition2D(caseCode);
                }
            }

            // indexy...


        }

        public static byte GetCaseCode2D(ref byte[] field, Vector2I fieldSize, int x, int y, byte isoLevel)
        {
            int cellIndex = x + y * fieldSize.X;
            return (byte)((field[cellIndex] > isoLevel ? 0x01 : 0)
                        | (field[cellIndex + 1] > isoLevel ? 0x02 : 0)
                        | (field[cellIndex + fieldSize.X] > isoLevel ? 0x04 : 0)
                        | (field[cellIndex + 1 + fieldSize.X] > isoLevel ? 0x08 : 0));
        }

        public static Vector2 GetVertexPosition2D(byte caseCode)
        {
            Vector2 cellVert = new(0, 0);
            int edgeCount = 0;

            for (int edgeCodeIndex = 0; edgeCodeIndex < 4; edgeCodeIndex++)
            {
                // získáme kod
                byte edgeCode = Tables.edgeCodeTable2D[caseCode, edgeCodeIndex];
                // check zda nejsme na konci
                if (edgeCode == 0x00)
                {
                    break;
                }
                // získáme indexy z kodu.
                byte cornerId0 = (byte)((edgeCode >> 4) & 0x0F); // první číslo
                byte cornerId1 = (byte)((edgeCode) & 0x0F); // druhé číslo
                // získáme 2D pozici z indexů
                Vector2 cornerV0 = new(cornerId0 % 2, cornerId0 / 2);
                Vector2 cornerV1 = new(cornerId1 % 2, cornerId1 / 2);

                Vector2 pos = (cornerV1 - cornerV0) * 0.5f + cornerV0;
                cellVert += pos;
                edgeCount++;
            }
            cellVert /= edgeCount;
            return cellVert;
        }




        public static byte GetCaseCode3D(ref byte[] field, Vector3I fieldSize, byte isoLevel, int cellIndex)
        {
            // spodní část krychle
            return (byte)((field[cellIndex] > isoLevel ? 0x01 : 0)
            | (field[cellIndex + 1] > isoLevel ? 0x02 : 0)
            | (field[cellIndex + fieldSize.X * fieldSize.Y] > isoLevel ? 0x04 : 0)
            | (field[cellIndex + 1 + fieldSize.X * fieldSize.Y] > isoLevel ? 0x08 : 0)
            // horní část krychle
            | (field[cellIndex + fieldSize.X] > isoLevel ? 0x10 : 0)
            | (field[cellIndex + 1 + fieldSize.X] > isoLevel ? 0x20 : 0)
            | (field[cellIndex + fieldSize.X * fieldSize.Y + fieldSize.X] > isoLevel ? 0x40 : 0)
            | (field[cellIndex + 1 + fieldSize.X * fieldSize.Y + fieldSize.X] > isoLevel ? 0x80 : 0));
        }

        public static Vector3 GetVertexPosition3D(ref byte[] field3D, Vector3I field3DSize, byte isoLevel, int cellIndex, byte caseCode)
        {
            Vector3 vertexPosition = new(0, 0, 0);
            int edgeCount = 0;
            // pro všechny body na hranách získáme jejich pozice a přičteme k vertexPosition
            for (int edgeCodeIndex = 0; edgeCodeIndex < 4; edgeCodeIndex++)
            {
                // získáme kod
                byte edgeCode = Tables.edgeCodeTable[caseCode, edgeCodeIndex];
                // check zda nejsme na konci
                if (edgeCode == 0x00) break;
                // získáme indexy z kodu.
                byte cornerId0 = (byte)((edgeCode >> 4) & 0x0F); // první číslo
                byte cornerId1 = (byte)((edgeCode) & 0x0F); // druhé číslo
                // získáme 2D pozici z indexů
                Vector3I cornerV0 = new(cornerId0 % 2, cornerId0 / 4, cornerId0 / 2 % 2);
                Vector3I cornerV1 = new(cornerId1 % 2, cornerId1 / 4, cornerId1 / 2 % 2);
                // vypočítáme interpolaci
                byte value0 = field3D[cellIndex + cornerV0.X + cornerV0.Y * field3DSize.X + cornerV0.Z * field3DSize.X * field3DSize.Y];
                byte value1 = field3D[cellIndex + cornerV1.X + cornerV1.Y * field3DSize.X + cornerV1.Z * field3DSize.X * field3DSize.Y];
                float interoplatedScale = Mathf.Abs((float)isoLevel - (float)value0) / Mathf.Abs((float)value0 - (float)value1);
                // získáme pozici na hraně
                Vector3 edgePosition = (Vector3)(cornerV1 - cornerV0) * interoplatedScale + cornerV0;
                // přičteme pro získání průměru
                vertexPosition += edgePosition;
                edgeCount++;
            }
            // získáme průměr
            vertexPosition /= edgeCount;
            return vertexPosition;
        }

        public static void GetIndices3D(byte caseCode, int vertexIndex, ref int[] indices, ref int writeIndex, Vector3I fieldSize)
        {
            for (int i = 0; i < 18; i++)
            {
                int index = Tables.indexTable3D[caseCode, i];
                if (index == -1) break;
                Vector3I indexV = new(index % 2, index / 4, (index / 2) % 2);
                indices[writeIndex] = vertexIndex + indexV.X + indexV.Y * (fieldSize.X - 1) + indexV.Z * (fieldSize.X - 1) * (fieldSize.Y - 1);
                writeIndex++;
            }
        }

        // PROBOLÉMY:
        // - mezery mezi vertexy. (ukládají se nepoužívané vertexy, vertexy(0, 0, 0))
        // - používá se pouze vertex shading. lepší by byla kombinace vertex a flat shading. ?
        public static Godot.ArrayMesh GenerateMesh3D(ref byte[] field, Vector3I fieldSize, byte isoLevel)
        {
            // Optimální process s podporou GPU:
            // skládá se z 3 cyklů kde jeden cykl projde přes celé pole.
            // (1) zjistit pole s indexy vertexů, tohle také vypočítá celkový počet vertexů. (CPU)
            // (2) vytvořit vertexy a indexy (GPU)
            // (3) vytvořit vertexy a indexy mezi chunky (CPU) (GPU?)
            // (4) vytvořit normály (GPU)


            // velikost pole buňek/vertexů
            Vector3I vertexFieldSize = fieldSize - new Vector3I(1, 1, 1);

            Vector3[] vertexPositions = new Vector3[vertexFieldSize.X * vertexFieldSize.Y * vertexFieldSize.Z];
            Vector3[] normals = new Vector3[vertexFieldSize.X * vertexFieldSize.Y * vertexFieldSize.Z];
            // max počet indexů pro bunku: 18
            int[] indices = new int[vertexFieldSize.X * vertexFieldSize.Y * vertexFieldSize.Z * 18];

            int writeIndex = 0; // předem spočítat?
            // pro každou buňku v poli zjistíme vertex.
            for (int z = 0; z < vertexFieldSize.Z; z++)
            {
                for (int y = 0; y < vertexFieldSize.Y; y++)
                {
                    for (int x = 0; x < vertexFieldSize.X; x++)
                    {
                        // index buňky v 3D poli
                        int cellIndex = x + y * fieldSize.X + z * fieldSize.X * fieldSize.Y;
                        // zjistíme o jakou konfiguraci se jedná.
                        byte caseCode = GetCaseCode3D(ref field, fieldSize, isoLevel, cellIndex);
                        // pokud se jedná o prázdnou konfiguraci tak pokračujem dál na další buňku.
                        if (caseCode == 0 || caseCode == 255) continue;
                        // pozice vertexu v poli vertexů
                        int vertexIndex = x + y * vertexFieldSize.X + z * vertexFieldSize.X * vertexFieldSize.Y;
                        // zjistníme pozici vertexu v buňce pomocí čísla konfigurace které vložíme do tabulky. (velmi rychlé)
                        vertexPositions[vertexIndex] = GetVertexPosition3D(ref field, fieldSize, isoLevel, cellIndex, caseCode) + new Vector3(x, y, z);


                        
                        if (x >= vertexFieldSize.X - 1 || y >= vertexFieldSize.Y - 1 || z >= vertexFieldSize.Z - 1) continue;
                        // přidat indices do pole podle caseCode
                        GetIndices3D(caseCode, vertexIndex, ref indices, ref writeIndex, fieldSize);
                    }
                }
            }


            // normals
            for (int i = 0; i < indices.Length / 3; i += 3)
            {
                int index0 = indices[i];
                int index1 = indices[i + 1];
                int index2 = indices[i + 2];

                Vector3 vert1 = vertexPositions[index0];
                Vector3 vert2 = vertexPositions[index1];
                Vector3 vert3 = vertexPositions[index2];

                Vector3 normal = (vert3 - vert1).Cross(vert2 - vert1).Normalized();
                // set indices!!
                normals[index0] += normal;
                normals[index1] += normal;
                normals[index2] += normal;

                // dík: https://computergraphics.stackexchange.com/questions/4031/programmatically-generating-vertex-normals
            }
            for (int i = 0; i < normals.Length; i++)
            {
                normals[i] = normals[i].Normalized();
            }


            // indexy...
            // podle toho na jaké straně je sighn change tak tam uděláme link.



            /*
            GD.Print("vertexPositions: ");
            for (int i = 0; i < vertexPositions.Length; i++)
            {
                GD.Print(vertexPositions[i], ", ");
            }
            GD.Print("indices: ");
            for (int i = 0; i < indices.Length; i++)
            {
                GD.Print(indices[i], ", ");
            }
            */


            /*
            int caseCodee = 128;
            GD.Print("caseCode: ", caseCodee);
            for (int i = 0; i < 18; i++)
            {
                int index = Tables.indexTable3D[caseCodee, i];
                if (index == -1) break;
                GD.Print("index: ", index);
            }
            */

            Godot.ArrayMesh arrayMesh = new ArrayMesh();
            Godot.Collections.Array arrays = [];
            arrays.Resize((int)Mesh.ArrayType.Max);
            arrays[(int)Mesh.ArrayType.Vertex] = vertexPositions;
            arrays[(int)Mesh.ArrayType.Normal] = normals;
            arrays[(int)Mesh.ArrayType.Index] = indices;
            arrayMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, arrays);
            return arrayMesh;
        }
    }
}

/*
* Zdroje:
*
* https://www.mattkeeter.com/projects/contours/
*
*
*
*/
/*
* Změny:
*
* [22.07.2025] vytvořeno
*
*
*/