using Godot;
using System;
using System.IO;
using System.IO.IsolatedStorage;

/*
*
*
*
*
*
*
*/

// funkce PlayerMovedToChunk [IMPLEMENTOVÁNO]
// kde se updatne LOD chunků
//  LOD Meshe.
//  LOD Collision. 
//      Chunky které jsou za nějakou hranicí už nebudou mít kolizi. [IMPLEMENTOVÁNO]
// Chunky za hranicí budou odebrány a místo nich budou vygenerovány nové.
//
// Načítání chunků, 2 typy:
//  (1) Pokud chunk nebyl nikdy vygenerován.
//      Pokud nebyl uložen v region souboru, tak bude pro něj vygenerován region soubor s okolnímy chunky a chunk bude načten.
//  (2) Pokud chunk už byl vyhenerován.
//      Tyto chunky budou uloženy do souborů (region souborů), kde kaaždý region bude mít nějaký počet chunků.
//
// Když bude chunk načten tak nějakej hustej chunk appear animace? (blink?)
//
// V jednen moment může být načteno pouze určený počet chunk meshů?
// Kolem POV pozice.
//
//

public partial class MCTerrain : Node3D
{

    [Export] NoiseTexture2D noiseTexture;

    MCChunkField ChunkField;
    MCChunkCollisionField CollisionField;
    Vector3I PlayerChunkPosition;


    //MCChunkCollision ChunkCollision1;



    // collision nodes
    // 2x2x2 chunk High quality
    // 6x6x6 - 2x2x2 Low Quality chunk
    // collision chunk - Quality setting

    //
    //
    //

    public override void _Ready()
    {
        // ChunkField Setuú
        ChunkField = new MCChunkField(new(8, 8, 8));
        AddChild(ChunkField);
        Image PerlinImage = noiseTexture.Noise.GetImage(ChunkField.ChunkFieldSize.X * MCChunk.FieldSize.X, ChunkField.ChunkFieldSize.Z * MCChunk.FieldSize.Z);
        SetPerlinTerrain(ref ChunkField, ref PerlinImage);
        // ChunkCollisionField Setup
        CollisionField = new MCChunkCollisionField();
        AddChild(CollisionField);
        PlayerChunkPosition = new(0, 0, 0);

        GD.Print("Generated Terrain");

        //File.WriteAllText("MCGameSave.txt", "Hello World File!");

        string AppDataDirectory = System.Environment.GetFolderPath(System.Environment.SpecialFolder.ApplicationData);
        //GD.Print("appdata Directory: ", Path.Combine(AppDataDirectory, "p1ga"));

        //File.WriteAllText("MCGameSave.txt", "Hello World File!");
        System.IO.Directory.CreateDirectory(Path.Combine(AppDataDirectory, "p1ga"));
        using (FileStream fs = File.Create(Path.Combine(AppDataDirectory, "p1ga", "MCGameSave.txt")))
        {
            byte[] info = new System.Text.UTF8Encoding(true).GetBytes("Hello World!");
            fs.Write(info, 0, info.Length);
        }

    }

    public void UpdatePovPosition(Vector3 PlayerPosition)
    {

        // lokální pozice relativní k MCTerrain bodu
        Vector3 LocalPosition = PlayerPosition - this.Position;
        // vygenerovat collision pro chunk pokud do něj hráč zrovna přešel.
        Vector3I ChunkPosition = (Vector3I)(LocalPosition / (Vector3)MCChunk.FieldSize).Floor();
        // check zda se hráč přesunul do nového chunku
        // pokud ne tak se nic neděje.
        if (ChunkPosition == PlayerChunkPosition)
        {
            return;
        }
        PlayerChunkPosition = ChunkPosition;

        //
        // Hráč vstoupil do nového chunku.
        //


        GD.Print("player stepped into new chunk");

        CollisionField.UpdateCollisionPov(ref ChunkField, PlayerChunkPosition);


        // update LOD chunků
        // bude potřeba:
        // -> vytvořit chunky nezávislé na pozici v array
        // -> vědět jaké chunky by měly změnit své lod.
        // -> marching cubes s různým lod


        // Load chunk at pov.
        // LoadChunk(position)
        // SetChunkPosition()
        // 
        //

    }

    public void ModifyIfColliding(GodotObject Collider, Vector3 Point, byte Amount, bool Subtract)
    {
        // nejdřív zkontrolujem zda vůbec kolidujem s terénem.
        // -> pokud ano tak budem pokračovat dál - získáme lokální bod.
        // -> pokud ne tak se vrátíme.

        if (!CollisionField.CheckIfColliding(Collider))
        {
            return;
        }

        Vector3 LocalPoint = Point - Transform.Origin;
        Vector3I FieldPosition = new((int)Mathf.Round(LocalPoint.X), (int)Mathf.Round(LocalPoint.Y), (int)Mathf.Round(LocalPoint.Z));

        // 3x3 grid
        for (int z = FieldPosition.Z - 2; z < FieldPosition.Z + 2; z++)
        {
            for (int y = FieldPosition.Y - 2; y < FieldPosition.Y + 2; y++)
            {
                for (int x = FieldPosition.X - 2; x < FieldPosition.X + 2; x++)
                {
                    Vector3I CellPosition = new(x, y, z);
                    Vector3 Distance = CellPosition - FieldPosition;
                    float InvertDist = 1.0f / Distance.Length();
                    if (InvertDist > 1.0f)
                    {
                        InvertDist = 1.0f;
                    }
                    byte InterpolatedAmount = Convert.ToByte(InvertDist * (float)Amount);

                    if (Subtract)
                    {
                        ChunkField.AddValue(CellPosition, InterpolatedAmount);
                    }
                    else
                    {
                        ChunkField.SubtractValue(CellPosition, InterpolatedAmount);
                    }
                }
            }
        }

        int[] ChunksToUpdate = new int[8] {
            -1, -1, -1, -1, -1, -1, -1, -1
        };
        int empty_field_index = 0;
        ChunkField.GetPointIndex(new(FieldPosition.X - 3, FieldPosition.Y - 3, FieldPosition.Z - 3), ref ChunksToUpdate[0], ref empty_field_index);
        ChunkField.GetPointIndex(new(FieldPosition.X + 3, FieldPosition.Y - 3, FieldPosition.Z - 3), ref ChunksToUpdate[1], ref empty_field_index);
        ChunkField.GetPointIndex(new(FieldPosition.X - 3, FieldPosition.Y + 3, FieldPosition.Z - 3), ref ChunksToUpdate[2], ref empty_field_index);
        ChunkField.GetPointIndex(new(FieldPosition.X + 3, FieldPosition.Y + 3, FieldPosition.Z - 3), ref ChunksToUpdate[3], ref empty_field_index);
        ChunkField.GetPointIndex(new(FieldPosition.X - 3, FieldPosition.Y - 3, FieldPosition.Z + 3), ref ChunksToUpdate[4], ref empty_field_index);
        ChunkField.GetPointIndex(new(FieldPosition.X + 3, FieldPosition.Y - 3, FieldPosition.Z + 3), ref ChunksToUpdate[5], ref empty_field_index);
        ChunkField.GetPointIndex(new(FieldPosition.X - 3, FieldPosition.Y + 3, FieldPosition.Z + 3), ref ChunksToUpdate[6], ref empty_field_index);
        ChunkField.GetPointIndex(new(FieldPosition.X + 3, FieldPosition.Y + 3, FieldPosition.Z + 3), ref ChunksToUpdate[7], ref empty_field_index);

        // podle začáteční a konečné pozice update fieldu zjistit všehcny zahrnuté chunky.
        // podle testování rohů tohoto fieldu.
        for (int i = 0; i < 8; i++)
        {
            if (ChunksToUpdate[i] != -1)
            {
                //ref MCChunk Chunk = ref Chunks[ChunksToUpdate[i]];
                ref MCChunk Chunk = ref ChunkField.GetChunk(ChunksToUpdate[i]);
                Vector3I ChunkPosition = new((int)Chunk.Position.X / MCChunk.FieldSize.X, (int)Chunk.Position.Y / MCChunk.FieldSize.Y, (int)Chunk.Position.Z / MCChunk.FieldSize.Z);
                //Godot.ArrayMesh ArrMesh = MarchingCubes.CreateMesh2(this, ChunkPosition);
                Godot.ArrayMesh ArrMesh = MCMeshAlgorithm.CreateMesh(ref ChunkField, ChunkPosition);
                Chunk.Mesh.Mesh = ArrMesh;
                //GD.Print("chunk has materials: ", Chunk.Mesh.GetSurfaceOverrideMaterialCount());
                // update kolize chunku.
                CollisionField.UpdateNearbyCollision(ref Chunk);
            }
        }
    }


    private void SetPerlinTerrain(ref MCChunkField ChunkField, ref Image PerlinImage)
    {
        for (int z = 0; z < ChunkField.ChunkFieldSize.Z; z++)
        {
            for (int y = 0; y < ChunkField.ChunkFieldSize.Y; y++)
            {
                for (int x = 0; x < ChunkField.ChunkFieldSize.X; x++)
                {
                    Vector3I ChunkPosition = new(x, y, z);
                    int ChunkIndex = ChunkField.GetChunkIndex(ChunkPosition);
                    ref MCChunk Chunk = ref ChunkField.GetChunk(ChunkIndex);
                    SetPerlinChunk(ref Chunk, ChunkPosition, ref PerlinImage);
                    //Godot.ArrayMesh ArrMesh = MarchingCubes.CreateMesh3(ref ChunkField, new(x, y, z));
                    //Chunk.Mesh.Mesh = ArrMesh;
                }
            }
        }

        for (int z = 0; z < ChunkField.ChunkFieldSize.Z; z++)
        {
            for (int y = 0; y < ChunkField.ChunkFieldSize.Y; y++)
            {
                for (int x = 0; x < ChunkField.ChunkFieldSize.X; x++)
                {
                    Vector3I ChunkPosition = new(x, y, z);
                    int ChunkIndex = ChunkField.GetChunkIndex(ChunkPosition);
                    ref MCChunk Chunk = ref ChunkField.GetChunk(ChunkIndex);
                    Godot.ArrayMesh ArrMesh = MCMeshAlgorithm.CreateMesh(ref ChunkField, new(x, y, z));
                    Chunk.Mesh.Mesh = ArrMesh;
                }
            }
        }
    }
    private void SetPerlinChunk(ref MCChunk Chunk, Vector3I ChunkPosition, ref Image PerlinImage)
    {
        for (int z = 0; z < MCChunk.FieldSize.Z; z++)
        {
            for (int y = 0; y < MCChunk.FieldSize.Y; y++)
            {
                for (int x = 0; x < MCChunk.FieldSize.X; x++)
                {
                    Vector3I CellPosition = new(ChunkPosition.X * MCChunk.FieldSize.X + x, ChunkPosition.Y * MCChunk.FieldSize.Y + y, ChunkPosition.Z * MCChunk.FieldSize.Z + z);
                    float TerrainHeight = PerlinImage.GetPixel(CellPosition.X, CellPosition.Z).R * 12.0f + 12.0f;

                    if (CellPosition.Y > TerrainHeight)
                    {
                        int CellIndex = x + y * MCChunk.FieldSize.X + z * MCChunk.FieldSize.X * MCChunk.FieldSize.Y;

                        if (CellPosition.Y - 1.0f < TerrainHeight)
                        {
                            float value = CellPosition.Y - TerrainHeight;
                            Chunk.Field[CellIndex] = (byte)(255 * value);
                        }
                        else
                        {
                            Chunk.Field[CellIndex] = 255;
                        }
                    }
                }
            }
        }
    }
}

// https://www.youtube.com/watch?v=5CKvGYqagyI
