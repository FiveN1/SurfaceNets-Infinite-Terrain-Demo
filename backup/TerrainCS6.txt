using Godot;
using System;
using System.IO;
// PLÁN NA ČISTÝ KOD!
// - nepoužívat static variable
// - nepoužívat inheritanci

public partial class Terrain : Node3D
{
    // Data třídy
    #region Data

    [Export] public NodePath MeshNodePath;
    Node3D MeshNode;
    StandardMaterial3D NodeMaterial;
    //OctreeNode RootNode;


    // TOHLE JE NAHOVNO POUŽÍVAT EVENT/SIGNAL!!
    [Export] public NodePath PlayerPath;
    CharacterBody3D Player;

    [Export] public NodePath WorldGeneratorPath;
    WorldGenerator WorldGen;

    int WorldScale;



    Octree.Node rootNode;


    #endregion Data

    // Funkce třídy
    #region Funkce
    public Terrain()
    {

    }

    public override void _Ready()
    {
        base._Ready();
        GD.Print("Happy World Daddy");

        NodeMaterial = GD.Load<StandardMaterial3D>("res://scenes/Application/Terrain/StandardMaterial1.tres"); // res://scenes/Application/Terrain/StandardTransparentMaterial.tres

        MeshNode = GetNode<Node3D>(MeshNodePath);
        GD.Print("node: ", MeshNode, " path: ", MeshNodePath);

        Player = GetNode<CharacterBody3D>(PlayerPath);

        WorldGen = GetNode<WorldGenerator>(WorldGeneratorPath);

        Octree.Tree.worldGen = GetNode<WorldGenerator>(WorldGeneratorPath);

        WorldScale = 2;
        //RootNode = new OctreeNode(new(0.0f, 0.0f, 0.0f), Mathf.Pow(2, WorldScale) * 8.0f, 0, null);
        //SubdivideIfClose(ref RootNode, new(0, 0, 0), 0, WorldScale);

        ChunkQueue chunkQueue = new ChunkQueue(MeshNode);


        //GetViewport().DebugDraw = Viewport.DebugDrawEnum.Wireframe;


        Octree.Node.SetMeshParentNode(MeshNode);
        StandardMaterial3D DebugBoxmaterial = GD.Load<StandardMaterial3D>("res://scenes/Application/Terrain/StandardTransparentMaterial.tres");
        Octree.Node.SetDebugMeshMaterial(DebugBoxmaterial);
        Octree.Node.EnableDebugVisuals(true);
        Octree.Node.SetChunkQueue(chunkQueue);

        rootNode = new Octree.Node(new(0.0f, 0.0f, 0.0f), Mathf.Pow(2, WorldScale) * Terrain22.Chunk.size, null);
        Octree.Tree.SubdivideIfClose(rootNode, new(0, 0, 0), 0, WorldScale);

        //rootNode.GetValue(new(0, 0, 0));

        //Octree.Node node1 = new Octree.Node(new(0.0f, 0.0f, 0.0f), 16.0f, null);
        //node1.Subdivide();
        //Terrain22.Chunk chunk = new Terrain22.Chunk(MeshNode);
        //Vector3I direction = new(1, 0, 0);
        //Octree.Node activeNode = node1.GetLeaf(3);
        //Octree.Node neighbor = activeNode.GetNeighbor(direction);
        // iterovat dokud nebude ve stejném levelu jako node.

        //if (neighbor.size == activeNode.size)
        //{
        //GD.Print("stejná velikost");
        // spojit. direction
        //}

        //GD.Print("Node: ", activeNode);
        //GD.Print("Neighbor: ", neighbor);

        /*
        string filename = "chunk.0.8.8.dat";

        string appDataDirectory = System.Environment.GetFolderPath(System.Environment.SpecialFolder.ApplicationData);
        appDataDirectory = Path.Combine(appDataDirectory, "p1ga", "chunks");
        string filePath = Path.Combine(appDataDirectory, filename);
        if (File.Exists(filePath))
        {
            byte[] fieldData = File.ReadAllBytes(filePath);
            //fieldData.CopyTo(this.field);

            for (int i = 0; i < fieldData.Length; i++)
            {
                GD.Print("byte: ", fieldData[i]);
            }
            

            GD.Print("loaded chunk from: ", filePath);
            return;
        }
        */

        Test1();


    }

    public override void _PhysicsProcess(double delta)
    {
        base._PhysicsProcess(delta);

        Vector3 PovPoint = Player.Position - Position;
        //SubdivideIfClose(ref RootNode, PovPoint, 0, WorldScale);

        //Octree.Tree.SubdivideIfClose(node1,);

        //Octree.Tree.SubdivideIfClose(rootNode, PovPoint, 0, WorldScale);
    }


    public void Test1()
    {
        // 3 array v jednom
        /*
        int chunkSize = 8;
        int leftChunkSize = 4;
        int coreSize = chunkSize * chunkSize;
        int edgeSize = 2 * chunkSize + 1;
        int[] vertices = new int[coreSize * coreSize];


        // position 1D
        // scale

        Vector2I direction = new(1, 0);
        float cellSize = 1.0f;

        float input = 0.25f;


        int index = (int)(input / cellSize);

        GD.Print("index: ", index);
        */

        // Metoda podporující octree Chunk:
        // při získávání vertexů z vedlejšícho chunku.
        // -> pro každý vertex:
        //      Zjistit velikost buňky.
        // pozici zao

        // pro buňku na hraně chunku:
        // rovnou vytvořit spoj s vedlejšími vertexy:
        // -> zjistit buňku které je třeba spojit.
        int chunkSize = 8;
        int[] chunkField1 = new int[chunkSize * chunkSize];

        for (int i = 0; i < chunkSize * chunkSize; i++)
        {
            chunkField1[i] = 1;
        }
        int[] chunkField2 = new int[chunkSize * chunkSize];

        for (int i = 0; i < chunkSize * chunkSize; i++)
        {
            chunkField2[i] = 2;
        }

        Vector2I pos = new(7, 0);
        Vector2I direction = new(1, 0);
        Vector2I posAtDirection = pos + direction;

        int value = 0;
        if (posAtDirection.X >= chunkSize)
        {
            // získat hodnotu
            value = chunkField2[posAtDirection.X % chunkSize + posAtDirection.Y * chunkSize];
        }
        else
        {
            value = chunkField1[posAtDirection.X + posAtDirection.Y * chunkSize];
        }
        GD.Print("value: ", value);
        // potom by tento verex byl přidán do pole.

        // connect:

        if (new Vector2(1, 0) < new Vector2(0.99f, 2))
        {
            GD.Print("is smaller");
        }





    }

    /*
    bool CheckIfNodeClose(ref OctreeNode ActiveNode, Vector3 Point)
    {
        // 
        float RenderDistanceScale = 2.0f;

        Vector3 CellCenterPos = ActiveNode.Position + new Vector3(ActiveNode.Size, ActiveNode.Size, ActiveNode.Size) * 0.5f;
        float dist = (CellCenterPos - Point).Length();
        if (dist < ActiveNode.Size * RenderDistanceScale)
        {
            return true;
        }
        return false;
    }

    void SubdivideIfClose(ref OctreeNode ActiveNode, Vector3 Point, int IterationCount, int MaxIterations) // max iterations
    {
        //
        // Update počtu iterace
        //
        IterationCount++;
        // pokud byla dosažena maximální iterace tak pouze nastavíme jeho panel
        if (IterationCount > MaxIterations)
        {
            ActiveNode.AddMesh(ref MeshNode, NodeMaterial, ref WorldGen);
            return;
        }
        //
        // Distance funkce
        //
        // pomocí distance funkce zjistíme zda by měl být node rozdělen na větší detail
        bool IsClose = CheckIfNodeClose(ref ActiveNode, Point);
        //
        // Operace bodu
        //
        // pokud by měl být orzdělen ale není (je blízko), rozdělíme ho.
        if (IsClose && ActiveNode.IsLeaf)
        {
            ActiveNode.Subdivide(ref MeshNode);
        }
        // pokud by neměl být rozdělen ale je (není blízko), přemeníme ho na list
        if (!IsClose && !ActiveNode.IsLeaf)
        {
            ActiveNode.UnSubdivide(ref MeshNode);
        }
        //
        // Následné operace
        //
        // pokud je po operaci listem, přidáme mu panel.
        if (ActiveNode.IsLeaf)
        {
            ActiveNode.AddMesh(ref MeshNode, NodeMaterial, ref WorldGen);
            return;
        }
        // pokud není po operaci listem, iterujem nad jeho listy
        // POZNÁMKA: iterujem od (+)konce aby bylo možné vytvořit spoje mezi chunky a nemuseli jsem iterovat znovu přes celý strom.
        for (int i = 7; i >= 0; i--)
        {
            SubdivideIfClose(ref ActiveNode.Leafs[i], Point, IterationCount, MaxIterations);
        }
    }
    */


    #endregion Funkce

}

/*
*
*                [Root]
*       [Chunk1], ... , [Chunk8]
* [Chunk1] ...
*
* Pro každý chunk může být 8 dalších chunků
*
*/

// PROBLÉM:
// objekty se neuvolnujou!!

/*
* Zdroje:
*
* DUAL CONTOURING:
* https://www.cs.rice.edu/~jwarren/papers/dualcontour.pdf
* https://www.mattkeeter.com/projects/contours/
* https://www.reddit.com/r/Unity3D/comments/ieenax/highaccuracy_dual_contouring_on_the_gpu_tech/
* https://voxel-tools.readthedocs.io/en/latest/smooth_terrain/
* https://www.graphics.rwth-aachen.de/publication/131/feature1.pdf
*
* TEXTURY:
* https://gamedev.stackexchange.com/questions/53272/how-to-texture-a-surface-generated-by-marching-cubes-algorithm
*
* CHUNK BLEND:
* https://ngildea.blogspot.com/2014/09/dual-contouring-chunked-terrain.html
* https://www.evl.uic.edu/vchand2/thesis/papers/Marching%20Cubes.pdf
* https://transvoxel.org//
* TransVoxel Algorithm
* https://www.youtube.com/watch?v=U6WhkL3IVYg&t=85s
*/

/*
* Plán:
*
* PRIORITA | PLÁN
*   (1)     [začistit kod]
*   (3)     [Vytvořit mesh z fieldu pomocí dual contouring]
*   (x)     [Vytvořit Octree terén]                         [HOTOVO]
*   (2)     [Implementovat ukládání octree]
*   (4)     [Různé materiály / textury]
*   (5)     [GPU Akcelerace]
*   (1)     [Chunk Blending]
*   (3)     [Isolevel zaležící na velikosti buněk!]
*   (5)     [Vzdálené chunky se nebudou renderovat?]
*   (1)     [Debug Mesh]
*/

// Každý chunk bude mít vlastní field, a mesh na určené velikosti. 
// místo add mesh funkce bude generate, kde field bude inicializován a nasteven pomocí noise funkce

/*
* Změny
*
* [16.07.2025] Vytvořeno, teď organizuji své scény a skripty dohromady.
* Tento nový terén bude založen na Octree systému a bude tvořen pomocí Dual Contouring metody nebo EMC metody ještě uvidím.
* Taky se tady budu snažit držet kod co nejlepší pro snadnou upravu v budoucnu.
* [17.07.2025] Přidán Octree systém
* [18.07.2025] Implementován jednoduchý dynamický Octree systém.
* [19.07.2025] implementace funkce hledání sousedů v octree.
* [20.07.2025] snaha přidat funkční chunk blending.
*/
