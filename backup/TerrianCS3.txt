using Godot;
using System;
using System.IO.IsolatedStorage;

/*
*
*
*
*
*
*
*/

// funkce PlayerMovedToChunk
// kde se updatne LOD chunků
//  LOD Meshe.
//  LOD Collision.
//      Chunky které jsou za nějakou hranicí už nebudou mít kolizi.
// Chunky za hranicí budou odebrány a místo nich budou vygenerovány nové.

public partial class Terrain : Node3D
{

    [Export] NoiseTexture2D noiseTexture;

    MCChunk[] Chunks;
    Vector3I ChunkSize;

    public byte NullFieldValue = 255;

    //
    //
    //

    public override void _Ready()
    {
        Material MeshMaterial = ResourceLoader.Load<Material>("res://materials/material1.tres");
        Godot.ArrayMesh arrMesh = GenerateMeshData2(100);
        MeshInstance3D GeneratedMesh = new MeshInstance3D();
        GeneratedMesh.Mesh = arrMesh;
        GeneratedMesh.SetSurfaceOverrideMaterial(0, MeshMaterial);
        GeneratedMesh.CreateTrimeshCollision();
        AddChild(GeneratedMesh);



        ChunkSize = new(8, 8, 8);
        Chunks = new MCChunk[ChunkSize.X * ChunkSize.Y * ChunkSize.Z];
        //
        // nastavení pozic
        // nastavení dat.

        Translate(new(0.0f, -24.0f, 0.0f));

        Image PerlinImage = noiseTexture.Noise.GetImage(ChunkSize.X * MCChunk.FieldSize.X, ChunkSize.Y * MCChunk.FieldSize.Y);
        for (int z = 0; z < ChunkSize.Z; z++)
        {
            for (int y = 0; y < ChunkSize.Y; y++)
            {
                for (int x = 0; x < ChunkSize.X; x++)
                {
                    ref MCChunk Chunk = ref Chunks[x + y * ChunkSize.X + z * ChunkSize.X * ChunkSize.Y];
                    Chunk = new MCChunk();
                    // žádné jiné transformace by pro chunk neměly proběhnout!!
                    Chunk.Translate(new(x * MCChunk.FieldSize.X, y * MCChunk.FieldSize.Y, z * MCChunk.FieldSize.Z));
                    SetChunkValues(Chunk, new(x, y, z), ref PerlinImage);

                    AddChild(Chunk);
                    
                    Chunk.Mesh.SetSurfaceOverrideMaterial(0, MeshMaterial);
                }
            }
        }

        for (int z = 0; z < ChunkSize.Z; z++)
        {
            for (int y = 0; y < ChunkSize.Y; y++)
            {
                for (int x = 0; x < ChunkSize.X; x++)
                {
                    int index = x + y * ChunkSize.X + z * ChunkSize.X * ChunkSize.Y;
                    Godot.ArrayMesh ArrMesh = MarchingCubes.CreateMesh2(this, new(x, y, z));
                    Chunks[index].Mesh.Mesh = ArrMesh;
                    Chunks[index].CreateCollision();
                }
            }
        }
    }

    public override void _PhysicsProcess(double delta)
    {

    }

    /*
    public void UpdateIfColliding(GodotObject Collider, Vector3 Point, byte Amount, bool Subtract)
    {



        for (int z = 0; z < ChunkSize.Z; z++)
        {
            for (int y = 0; y < ChunkSize.Y; y++)
            {
                for (int x = 0; x < ChunkSize.X; x++)
                {
                    int index = x + y * ChunkSize.X + z * ChunkSize.X * ChunkSize.Y;
                    //ref MCChunk Chunk = ref Chunks[index];
                    if (Collider == Chunks[index].GetCollider())
                    {
                        // modifikovat kolem !!
                        // najít všechny chunky které budou modifikovány
                        //  3x3 kolem chunku s bodem
                        // upravit podle distance


                        Vector3 LocalPoint = Point - Transform.Origin;
                        Vector3I FieldPosition = new((int)LocalPoint.X, (int)LocalPoint.Y, (int)LocalPoint.Z);


                        //ModifySection()


                        GD.Print("FieldPosition: ", FieldPosition, "LocalPoint: ", LocalPoint, "Point: ", Point);

                        ref byte FieldValue = ref GetFieldValue(FieldPosition);

                        if (FieldValue <= 255 - Amount && Subtract)
                        {
                            FieldValue += Amount;
                        }
                        else if (FieldValue >= Amount && !Subtract)
                        {
                            FieldValue -= Amount;
                        }

                        Godot.ArrayMesh ArrMesh = MarchingCubes.CreateMesh2(this, new(x, y, z));
                        Chunks[index].Mesh.Mesh = ArrMesh;
                        Chunks[index].CreateCollision();
                    }
                }
            }
        }


        // (1) check zda koliduje s nějakým chunkem.
        //      zjistit s jakým
        // (2) upravit body v okolí bodu.
        // (3) Zjistit jaké chunky byly upraveny a updatenout je.
        //      Nebo prostě updatenout všehcny chunky prozatím...?

    }
    */

    public void UpdateIfColliding2(GodotObject Collider, Vector3 Point, byte Amount, bool Subtract)
    {
        Vector3 LocalPoint = Point - Transform.Origin;
        Vector3I FieldPosition = new((int)Mathf.Round(LocalPoint.X), (int)Mathf.Round(LocalPoint.Y), (int)Mathf.Round(LocalPoint.Z));



        // přidat check !!
        // 3x3 grid
        for (int z = FieldPosition.Z - 2; z < FieldPosition.Z + 2; z++)
        {
            for (int y = FieldPosition.Y - 2; y < FieldPosition.Y + 2; y++)
            {
                for (int x = FieldPosition.X - 2; x < FieldPosition.X + 2; x++)
                {
                    Vector3I CellPosition = new(x, y, z);
                    Vector3 Distance = CellPosition - FieldPosition;
                    float InvertDist = 1.0f / Distance.Length();
                    if (InvertDist > 1.0f)
                    {
                        InvertDist = 1.0f;
                    }
                    byte InterpolatedAmount = Convert.ToByte(InvertDist * (float)Amount);
                    ModifyField(CellPosition, InterpolatedAmount, Subtract);
                }
            }
        }

        int[] ChunksToUpdate = new int[8] {
            -1, -1, -1, -1, -1, -1, -1, -1
        };
        ChunksToUpdate[0] = GetChunkIndex(new(FieldPosition.X - 3, FieldPosition.Y - 3, FieldPosition.Z - 3));
        ChunksToUpdate[1] = GetChunkIndex(new(FieldPosition.X + 3, FieldPosition.Y - 3, FieldPosition.Z - 3));
        ChunksToUpdate[2] = GetChunkIndex(new(FieldPosition.X - 3, FieldPosition.Y + 3, FieldPosition.Z - 3));
        ChunksToUpdate[3] = GetChunkIndex(new(FieldPosition.X + 3, FieldPosition.Y + 3, FieldPosition.Z - 3));
        ChunksToUpdate[4] = GetChunkIndex(new(FieldPosition.X - 3, FieldPosition.Y - 3, FieldPosition.Z + 3));
        ChunksToUpdate[5] = GetChunkIndex(new(FieldPosition.X + 3, FieldPosition.Y - 3, FieldPosition.Z + 3));
        ChunksToUpdate[6] = GetChunkIndex(new(FieldPosition.X - 3, FieldPosition.Y + 3, FieldPosition.Z + 3));
        ChunksToUpdate[7] = GetChunkIndex(new(FieldPosition.X + 3, FieldPosition.Y + 3, FieldPosition.Z + 3));

        // podle začáteční a konečné pozice update fieldu zjistit všehcny zahrnuté chunky.
        // podle testování rohů tohoto fieldu.
        for (int i = 0; i < 8; i++)
        {
            if (ChunksToUpdate[i] != -1)
            {
                ref MCChunk Chunk = ref Chunks[ChunksToUpdate[i]];
                Vector3I ChunkPosition = new((int)Chunk.Position.X / MCChunk.FieldSize.X, (int)Chunk.Position.Y / MCChunk.FieldSize.Y, (int)Chunk.Position.Z / MCChunk.FieldSize.Z);
                //GD.Print("chunk: ", ChunkPosition);
                //int index = x + y * ChunkSize.X + z * ChunkSize.X * ChunkSize.Y;
                Godot.ArrayMesh ArrMesh = MarchingCubes.CreateMesh2(this, ChunkPosition);
                Chunks[ChunksToUpdate[i]].Mesh.Mesh = ArrMesh;
                Chunks[ChunksToUpdate[i]].CreateCollision();
            }
        }


        // update všech chunků
        for (int z = 0; z < ChunkSize.Z; z++)
        {
            for (int y = 0; y < ChunkSize.Y; y++)
            {
                for (int x = 0; x < ChunkSize.X; x++)
                {
                    //int index = x + y * ChunkSize.X + z * ChunkSize.X * ChunkSize.Y;
                    //Godot.ArrayMesh ArrMesh = MarchingCubes.CreateMesh2(this, new(x, y, z));
                    //Chunks[index].Mesh.Mesh = ArrMesh;
                    //Chunks[index].CreateCollision();
                }
            }
        }
    }

    public void ModifyField(Vector3I Point, byte Amount, bool Subtract)
    {

        ref byte FieldValue = ref GetFieldValue(Point);

        if (FieldValue <= 255 - Amount && Subtract)
        {
            FieldValue += Amount;
        }
        else if (FieldValue >= Amount && !Subtract)
        {
            FieldValue -= Amount;
        }
    }

    //
    //
    //

    private void ModifySection()
    {

    }


    private void SetChunkValues(MCChunk Chunk, Vector3I ChunkPosition, ref Image PerlinImage)
    {
        for (int z = 0; z < MCChunk.FieldSize.Z; z++)
        {
            for (int y = 0; y < MCChunk.FieldSize.Y; y++)
            {
                for (int x = 0; x < MCChunk.FieldSize.X; x++)
                {
                    Vector3I CellPosition = new(ChunkPosition.X * MCChunk.FieldSize.X + x, ChunkPosition.Y * MCChunk.FieldSize.Y + y, ChunkPosition.Z * MCChunk.FieldSize.Z + z);
                    float TerrainHeight = PerlinImage.GetPixel(CellPosition.X, CellPosition.Z).R * 8.0f + 12.0f;

                    if (CellPosition.Y > TerrainHeight)
                    {
                        int CellIndex = x + y * MCChunk.FieldSize.X + z * MCChunk.FieldSize.X * MCChunk.FieldSize.Y;

                        if (CellPosition.Y - 1.0f < TerrainHeight)
                        {
                            float value = CellPosition.Y - TerrainHeight;
                            Chunk.Field[CellIndex] = (byte)(255 * value);
                        }
                        else
                        {
                            Chunk.Field[CellIndex] = 255;
                        }
                    }
                }
            }
        }
    }

    public ref byte GetFieldValue(Vector3I Position)
    {
        // pozice chunku
        // pokud chunk mimo range tak vrátí 0
        Vector3I ChunkPosition = new(Position.X / MCChunk.FieldSize.X, Position.Y / MCChunk.FieldSize.Y, Position.Z / MCChunk.FieldSize.Z);
        // tohle není moc hezké ale aspon bezpečné
        if (ChunkPosition.X >= ChunkSize.X || ChunkPosition.Y >= ChunkSize.Y || ChunkPosition.Z >= ChunkSize.Z || Position.X < 0 || Position.Y < 0 || Position.Z < 0)
        {
            return ref NullFieldValue;
        }
        // index chunku
        int ChunkIndex = ChunkPosition.X + ChunkPosition.Y * ChunkSize.X + ChunkPosition.Z * ChunkSize.X * ChunkSize.Y;
        // pozice voxelu v chunku
        Vector3I PositionInChunk = new(Position.X % MCChunk.FieldSize.X, Position.Y % MCChunk.FieldSize.Y, Position.Z % MCChunk.FieldSize.Z);
        // index voxelu v chunku
        int FieldIndex = PositionInChunk.X + PositionInChunk.Y * MCChunk.FieldSize.X + PositionInChunk.Z * MCChunk.FieldSize.X * MCChunk.FieldSize.Y;
        // získá hodnotu v chunku.
        return ref Chunks[ChunkIndex].Field[FieldIndex];
    }

    public int GetChunkIndex(Vector3I Position)
    {
        // pozice chunku
        // pokud chunk mimo range tak vrátí 0
        Vector3I ChunkPosition = new(Position.X / MCChunk.FieldSize.X, Position.Y / MCChunk.FieldSize.Y, Position.Z / MCChunk.FieldSize.Z);
        // tohle není moc hezké ale aspon bezpečné
        if (ChunkPosition.X >= ChunkSize.X || ChunkPosition.Y >= ChunkSize.Y || ChunkPosition.Z >= ChunkSize.Z || Position.X < 0 || Position.Y < 0 || Position.Z < 0)
        {
            return -1;
        }
        // index chunku
        int ChunkIndex = ChunkPosition.X + ChunkPosition.Y * ChunkSize.X + ChunkPosition.Z * ChunkSize.X * ChunkSize.Y;
        return ChunkIndex;
    }

    private Godot.ArrayMesh GenerateMeshData2(int size)
    {

        // define
        Vector3[] vertices = new Vector3[(size - 1) * (size - 1) * 6];
        Vector3[] normals = new Vector3[(size - 1) * (size - 1) * 6];
        int[] indices = new int[(size - 1) * (size - 1) * 6];


        float[] height_map = new float[size * size];



        //Image image1 = noiseTexture.GetImage();
        //byte[] data = image.GetData();
        Image image1 = noiseTexture.Noise.GetImage(size, size);
        //Noise noise1 = noiseTexture.Noise;
        GD.Print(image1.GetWidth());
        GD.Print(image1.GetPixel(0, 0));

        for (int y = 0; y < size; y++)
        {
            for (int x = 0; x < size; x++)
            {
                //GD.Print(image.GetPixel(x, y));
                //height_map[x + y * size] = (GD.Randi() % 100) * 0.01f - 1.0f;
                height_map[x + y * size] = image1.GetPixel(x, y).R * 10.0f - 10.0f;
            }
        }
        // vertices
        for (int y = 0; y < size - 1; y++)
        {
            for (int x = 0; x < size - 1; x++)
            {

                int i = (x + y * (size - 1)) * 6;
                vertices[i] = new Vector3(x, height_map[x + y * size], y);
                vertices[i + 1] = new Vector3(x + 1, height_map[x + 1 + y * size], y);
                vertices[i + 2] = new Vector3(x, height_map[x + (y + 1) * size], y + 1);

                vertices[i + 3] = new Vector3(x + 1, height_map[x + 1 + y * size], y);
                vertices[i + 4] = new Vector3(x + 1, height_map[x + 1 + (y + 1) * size], y + 1);
                vertices[i + 5] = new Vector3(x, height_map[x + (y + 1) * size], y + 1);


                Vector3 v1 = vertices[i + 1] - vertices[i];
                Vector3 v2 = vertices[i + 2] - vertices[i];
                Vector3 cross1 = v2.Cross(v1);
                cross1 = cross1.Normalized();

                normals[i] = cross1;
                normals[i + 1] = cross1;
                normals[i + 2] = cross1;

                Vector3 v3 = vertices[i + 1] - vertices[i + 4];
                Vector3 v4 = vertices[i + 2] - vertices[i + 4];
                Vector3 cross2 = v3.Cross(v4);
                cross2 = cross2.Normalized();

                normals[i + 3] = cross2;
                normals[i + 4] = cross2;
                normals[i + 5] = cross2;



                indices[i] = i;
                indices[i + 1] = i + 1;
                indices[i + 2] = i + 2;

                indices[i + 3] = i + 3;
                indices[i + 4] = i + 4;
                indices[i + 5] = i + 5;

            }
        }


        Godot.ArrayMesh arrMesh = new ArrayMesh();
        Godot.Collections.Array arrays = [];
        arrays.Resize((int)Mesh.ArrayType.Max);
        arrays[(int)Mesh.ArrayType.Vertex] = vertices;
        arrays[(int)Mesh.ArrayType.Normal] = normals;
        //arrays[(int)Mesh.ArrayType.Index] = indices;
        arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, arrays);
        return arrMesh;
    }


    private void CreateChunkMesh()
    {

    }

}

// https://www.youtube.com/watch?v=5CKvGYqagyI
