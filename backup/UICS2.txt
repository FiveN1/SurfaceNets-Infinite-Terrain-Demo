using Godot;
using System;
using System.Collections.Generic;
using System.Drawing;

public partial class Octree : Panel
{
    public Octree[] Children;
    bool IsLeaf;
    public Octree(Vector2 OctPosition, Vector2 OctSize)
    {
        Children = new Octree[4];
        IsLeaf = true;
        SetPosition(OctPosition);
        SetSize(OctSize);
    }
    public override void _Ready()
    {
        base._Ready();
        StyleBoxFlat newStyle = new StyleBoxFlat();
        newStyle.SetBgColor(new Godot.Color((GD.Randi() % 100) * 0.01f, (GD.Randi() % 100) * 0.01f, (GD.Randi() % 100) * 0.01f, 1));
        AddThemeStyleboxOverride("panel", newStyle);
    }


    // subdevide

    public void Subdevide()
    {
        IsLeaf = false;

        for (int y = 0; y < 2; y++)
        {
            for (int x = 0; x < 2; x++)
            {
                //...

                int index = x + y * 2;
                Children[index] = new Octree(new(x * Size.X * 0.5f, y * Size.Y * 0.5f), Size * 0.5f);
                AddChild(Children[index]);
            }
        }
    }

}

public partial class QuadPoint : Panel
{
    // reference na další 4 quadpointy v spodníl layer.

    // subdevide
    // - layer pod kterým leží tento quadpoint

    bool changed;

    public QuadPoint(Vector2 OctPosition, Vector2 OctSize)
    {
        //Children = new Octree[4];
        //IsLeaf = true;
        SetPosition(OctPosition);
        SetSize(OctSize);
        changed = false;
    }
    public override void _Ready()
    {
        base._Ready();
        StyleBoxFlat newStyle = new StyleBoxFlat();
        newStyle.SetBgColor(new Godot.Color((GD.Randi() % 100) * 0.01f, (GD.Randi() % 100) * 0.01f, (GD.Randi() % 100) * 0.01f, 1));
        AddThemeStyleboxOverride("panel", newStyle);
    }

    public void Subdivide(List<QuadPoint> Layer)
    {
        for (int y = 0; y < 2; y++)
        {
            for (int x = 0; x < 2; x++)
            {
                QuadPoint cell = new QuadPoint(new(x * Size.X * 0.5f, y * Size.Y * 0.5f), Size * 0.5f);
                Layer.Add(cell);
                AddChild(cell);
            }
        }
    }


}



public partial class Ui : Control
{

    [Export] NodePath FpsCounterPath;
    Label FpsCounter;

    public override void _Ready()
    {
        FpsCounter = GetNode<Label>(FpsCounterPath);


        Node2D PanelNode = new Node2D();
        AddChild(PanelNode);


        QuadTreeDemo QDDemo = new QuadTreeDemo();
        AddChild(QDDemo);
        QDDemo.UpdatePovPoint(new(512.0f, 150.0f), ref PanelNode);
        GD.Print("......");
        QDDemo.UpdatePovPoint(new(400.0f, 0.0f), ref PanelNode);
        //QDDemo.UpdatePovPoint(new(400.0f, 400.0f));
        //QDDemo.GeneratePanels();




        // generate octree.


        Vector2 PovPoint2 = new(170, 250);

        // quad-strom
        // L1      [...]
        // L2   [   ...   ]
        // L3 [     ...    ]
        // root?
        List<List<QuadPoint>> QuadTree = new List<List<QuadPoint>>();
        int layers = 4;
        for (int layer = 0; layer < layers; layer++)
        {
            QuadTree.Add(new List<QuadPoint>());
        }


        // potom traversujem strom a vytvoříme panely podle toho které je potřeba změnit.
        //List<Panel> QuadTreePanels;
        // bude obsahovat: bool changed, size, position

        // root
        QuadPoint root = new QuadPoint(new(0, 0), new(400, 400));
        AddChild(root);
        root.Subdivide(QuadTree[0]);

        // construct tree
        for (int layer = 0; layer < layers - 1; layer++)
        {
            for (int cellIndex = 0; cellIndex < QuadTree[layer].Count; cellIndex++)
            {
                QuadPoint cell = QuadTree[layer][cellIndex];
                Vector2 CellCenterPos = cell.GlobalPosition + cell.Size * 0.5f;
                float dist = (CellCenterPos - PovPoint2).Length();

                if (dist < cell.Size.X * 1.0f)
                {
                    cell.Subdivide(QuadTree[layer + 1]);
                }
            }


            // in layer:
            // > check každý bod zda je v blízkosti
            // > pokud ano tak rozdělit a přidat do nového layeru.
            // opakovat
        }



        Panel panel2 = new Panel();
        panel2.SetPosition(new(PovPoint2.X - 2, PovPoint2.Y - 2));
        panel2.SetSize(new Vector2(4, 4));
        AddChild(panel2);
        StyleBoxFlat newStyle2 = new StyleBoxFlat();
        newStyle2.SetBgColor(new Godot.Color(1, 1, 1, 1));
        panel2.AddThemeStyleboxOverride("panel", newStyle2);


        // vytvoříme strom...

        // první layer už musí být předem rozdělen...
        //
        // in layer:
        // > check každý bod zda je v blízkosti
        // > pokud ano tak rozdělit a přidat do nového layeru.
        // opakovat

        // base resolution = 16
        // max resolution = maxint což je (x) iterací.
        // for x iterací (od největšího) iterovat přez octree do nejmenčího


        // (1) zjistit největší rozlišení octree.
        // (2) iterovat dokud nenajdeme bod v octree.
        //


        // nevím co dělám!!
        // nejjednodušší cíl.
        // -> zjistit ve kterém octantu leží bod.
        // -> rozdělit octree


        // (1) vytvořit strom tak aby jeho leaf obsahoval bod.


        // detail octree je určen vzdáleností od bodu...
        // největší chunky by měly být co nejdál.
        // a nejmenší co nejblíž.


        // (1) vytvořit strom
        // (2) získat informace o polích která se změnila
        // (3) updatenout pole která se změnila.

        // 

    }

    public override void _PhysicsProcess(double delta)
    {
        FpsCounter.Text = $"{Engine.GetFramesPerSecond()}fps";
    }


}

/*
Octree RootOctree = new Octree(new(0, 0), new(400, 400));
        //RootOctree.Subdevide();
        AddChild(RootOctree);
        //RootOctree.Subdevide();
        //RootOctree.Children[0].Subdevide();
        //RootOctree.Children[0].Children[1].Subdevide();

        Vector2 PovPoint = new(260, 240);
        Panel panel1 = new Panel();
        panel1.SetPosition(new(PovPoint.X - 2, PovPoint.Y - 2));
        panel1.SetSize(new Vector2(4, 4));
        AddChild(panel1);
        StyleBoxFlat newStyle = new StyleBoxFlat();
        newStyle.SetBgColor(new Godot.Color(1, 1, 1, 1));
        panel1.AddThemeStyleboxOverride("panel", newStyle);

        for (int iteration = 0; iteration < 4; iteration++)
        {
            RootOctree.Subdevide();

            bool contains_point = false;

            for (int i = 0; i < 4; i++)
            {
                ref Octree ChildOctant = ref RootOctree.Children[i];
                float distance = ((ChildOctant.GlobalPosition + ChildOctant.Size) - PovPoint).Length();
                GD.Print("octant layer: ", i, ", position: ", ChildOctant.GlobalPosition, "distance: ", distance);

                // pomocí levelu na kterém je oktant a vzdálenosti určit zda by chunk měl být dále rozložen.
                // -> vzdálenost od rohu chunku?
                // 


                if (PovPoint.X >= ChildOctant.GlobalPosition.X && PovPoint.X < ChildOctant.GlobalPosition.X + ChildOctant.Size.X &&
                PovPoint.Y >= ChildOctant.GlobalPosition.Y && PovPoint.Y < ChildOctant.GlobalPosition.Y + ChildOctant.Size.Y)
                {
                    RootOctree = RootOctree.Children[i];
                    GD.Print("REPLACED");
                    contains_point = true;
                    break;
                }

            }
            if (contains_point == false)
            {
                GD.PrintErr("point not in world");
                break;
            }
        }

*/